---
title  Архітектурні принципи проектування розподілених інформаційних систем
---
# Архітектурні принципи проектування розподілених інформаційних систем

Архітектура програмного забезпечення - сукупність найважливіших рішень про організацію програмної системи, яка включає вибір структурних елементів, їх інтерфейсів, за допомогою яких складена система, а також їх поведінки в рамках взаємодії структурних елементів;

## Клієнт-серверна архітектура 

Клієнт-серверна архітектура передбачає розділення системи на дві групи компонентів: ті, що надають деяке обслуговування, - сервери, та ті які здійснюють запити до серверів в очікуванні обслуговування. Ці групи компонентів можуть розміщуватися в різних обчислювальних вузлах, з'єднаних обчислювальною мережею

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

        node  apps[
            Сервер
        ]
        node  dps[
            Клієнт
        ]
    
    
    dps - apps   

@enduml

</center>

Взаємодія клієнта і сервера здійснюєтося наступним чином

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant Client
participant Server


Client -> Server : request
Server -> Server
Client <- Server : response

@enduml

</center>


Одне з головних питань - це те, яким чином розділити клієнта і сервер. В застосунках, призначених для організації доступу користувачів до баз даних, рекомендують розглядати три рівня:
- рівень подання (інтерфейсу користувача);
- рівень бізнес-логіки (оброблення даних);
- рівень даних.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml


[Presentation Layer] ..> [Business Logic Layer]
[Business Logic Layer] ..> [Data Layer]


@enduml

</center>

Рівень подання зазвичай реалізується в клієнтах і містить програмний код, що забезпечує взаємодію користувача з застосунком. Складність цього програмного забезпечення може бути різною. Найпростіший варіант - Command Line Interface (CLI), в інших випадках - багаторівневий графічний інтерфейс користувача, реалізований у відповідності до моделі Model-View-ViewModel (MVVM).

Рівень бізнес-логіки містить сукупність правил, принципів і залежностей поведінки об'єктів предметної області, наприклад бухгалтегського обліку, управління підприємством, електронна комерція та ін.

На рівні даних розташовується програмне забезпечення, яке надає дані рівню бізнес-логіки та забезпечує їх персистентність, цілісність, конкурентний доступ. Таке програмне забезпечення зазвичай реалізує функціональність СУБД. 

Найпростіший варіант клієнт-серверної архітектури передбачає, що клієнт не несе ніякого функціонального навантаження крім відображення інформації, що надається сервером.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

node Client {
    [Presentation Layer]
}

node  Server {
    [Business Logic Layer]
    [Data Layer]
}

[Presentation Layer] .> [Business Logic Layer]
[Business Logic Layer] .> [Data Layer]


@enduml

</center>

Дворівнева клієнт-серверна архітектура передбачає використання "товстих" клієнтів, які відповідальні за оброблення всіх даних та їх відображення. Сервер реалізовує лише функції збереження та надання даних. При цьому розподілення обчислювального навантаження між клієнтом і сервером складає 80/20. Проте саме сервер СУБД найчастіше стає в такій системі вузькім місцем.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

node Client {
    [Presentation Layer]
    [Business Logic Layer]
}

node  Server {
    [Data Layer]
}

[Presentation Layer] .> [Business Logic Layer]
[Business Logic Layer] .> [Data Layer]


@enduml

</center>

Застосунки в рамках такої архітектури часто вимагають встановлення індивідуального з'єднання з базою даних для кожного з клієнтів. Постійна піддтримка великої кількості таких з'єднань потребує використання великої кількості ресурсів, нестача яких прозводить до перевантаження сервера та уповільнення оброблення клієнтських запитів.

Ще одним з суттєвих недоліків такого архітектурного рішення є те, що код застосунку виконується в кожному клієнті і кожне оновлення застосунку потребує перевстановлення на кожній робочій станції, що підвищує до нейприйнятного рівня вартість і складність адміністрування таких систем.

Багарошарові архітектури клієнт-сервер продовжують розвиток ідеї розділення застосунків на рівня подання, бізнес-логіки та даних до виділення слабко пов'язаних логічних компонентів та розташування їх в окремих серверах (сервери застосунків). Це забезпечило можливість перенести частину бізнес-логіки на серверні компоненти. За рахунок цього з'явилася можливість  використання пулів з'єднань з базою даних, частково спростилося адміністрування системи.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

node Client {
    [Presentation Layer]
    [UI Logic]
}

node ApplicationServer as "Application Server"{
    [Business Logic Layer]
}

database  DBMS {
    [Data Layer]
}

[Presentation Layer] .> [UI Logic]
[UI Logic] .> [Business Logic Layer]
[Business Logic Layer] .> [Data Layer]


@enduml

</center>


## Сервіс-оріентована архітектура 

Сервіс-орієнтована архітектура (Service-Oriented Architecture, SOA) – модульний підхід до розробки програмного забезпечення, що базується на використанні розподілених, слабо пов’язаних (англ. Low Coupling) замінних компонентів, оснащених стандартизованими інтерфейсами для взаємодії за стандартизованими протоколами. Програмні комплекси, розроблені відповідно до сервіс-орієнтованої архітектури, зазвичай реалізуються як набір веб-служб, взаємодіючих по стандартним мережевим протоколам. 
Інтерфейси компонентів в сервіс-орієнтованої архітектури інкапсулюють деталі реалізації (операційну систему, платформу, мову програмування) від інших компонентів, таким чином забезпечуючи комбінування і багаторазове використання компонентів для побудови складних розподілених програмних комплексів, забезпечуючи незалежність від використовуваних платформ та інструментів розробки, сприяючи масштабованості і керованості створюваних систем.

***Сервісні компоненти*** (чи сервіси) описуються програмними компонентами, що
забезпечують прозору мережеву адресацію. Сервіси - це відкриті, самовизначальні
компоненти, що підтримують швидку побудову розподілених застосунків.
При цьому немає чіткого визначення, який об'єм послуг повинен надавати окремий
сервіс, а ці послуги в мережах можуть розрізнятися наступним чином:
- ***Програмне забезпечення як послуга*** (SaaS, англ. Software-as-a-Service) – модель, в
якій споживачеві надається можливість використання прикладного програмного
забезпечення провайдера, що працює в хмарній інфраструктурі і доступного з різних
клієнтських пристроїв або за допомогою тонкого клієнта, наприклад, з браузеру (веб-пошта)
або інтерфейс програми. Контроль і управління основною фізичною і віртуальною
інфраструктурою хмари, у тому числі мережі, серверів, операційних систем, зберігання, або
навіть індивідуальних можливостей додатка (за винятком обмеженого набору призначених
для користувача налаштувань конфігурації додатка) здійснюється хмарним провайдером.
- ***Платформа як послуга*** (PaaS, англ. Platform-as-a-Service) – модель, коли
споживачеві надається можливість використання хмарної інфраструктури для розміщення
базового програмного забезпечення для наступного розміщення на нім нових або існуючих
застосувань (власних, розроблених на замовлення або придбаних тиражованих застосувань).
До складу таких платформ входять інструментальні засоби створення, тестування і
виконання прикладного програмного забезпечення – системи управління базами даних,
єднальне програмне забезпечення, середовища виконання мов програмування - надаються
хмарним провайдером. Контроль і управління основною фізичною і віртуальною
інфраструктурою хмари, у тому числі мережі, серверів, операційних систем, зберігання
здійснюється хмарним провайдером, за винятком розроблених або встановлених
застосувань, а також, по можливості, параметрів конфігурації середовища (платформи).
- ***Інфраструктура як послуга*** (IaaS, англ. IaaS or Infrastructure-as-a-Service) –
надається як можливість використання хмарної інфраструктури для самостійного управління
ресурсами обробки, зберігання, мереж і іншими фундаментальними обчислювальними
ресурсами, наприклад, споживач може встановлювати і запускати довільне програмне
забезпечення, яке може включати операційні системи, платформене і прикладне програмне
забезпечення. Споживач може контролювати операційні системи, віртуальні системи
зберігання даних і встановлені застосування, а також обмежений контроль набору доступних
сервісів (наприклад, міжмережевий екран, DNS). Контроль і управління основною фізичною і
віртуальною інфраструктурою хмари, у тому числі мережі, серверів, типів використовуваних
операційних систем, систем зберігання здійснюється хмарним провайдером.
Необхідно враховувати, що при реалізації дрібномодульного сервісу для отримання
бажаного результату необхідно забезпечити координовану роботу декількох сервісів. В
цьому випадку можна надавати елементарний об'єм функціонального навантаження і
забезпечувати високу міру повторного використання. А використання крупномодульних
сервісів, дозволяє забезпечити хорошу інкапсуляцію функціональності, але ускладнює
повторне використання цих вузькоспеціалізованих сервісів.

***Інтерфейс*** забезпечує опис можливостей і якості послуг, що надаються, конкретним
сервісом. У інтерфейсі визначається формат повідомлень, використовуваний для обміну
інформацією, а також вхідні і вихідні параметри методів, підтримуваних сервісним
компонентом. Від вибору мови і способу опису інтерфейсу залежать можливості програмної
сумісності різних реалізацій сервіс-орієнтованої архітектури.

***Транспорт*** забезпечує обмін інформацією між окремими сервісними компонентами.
Разом з відкритими стандартами опису інтерфейсів, використання гнучких транспортних
протоколів для обміну інформацією між сервісними компонентами дозволяє підвищити
програмну сумісність сервіс-орієнтованої системи.

***Реєстри*** сервісів використовуються для пошуку сервісних компонентів, що
забезпечують необхідну функціональність. Серед усієї множини різних систем, що
забезпечують виявлення сервісів, можна виділити дві основні категорії: системи
динамічного виявлення і системи статичного виявлення. *Статичні* системи виявлення сервісів (наприклад, UDDI) орієнтовані на зберігання інформації про сервіси в системах, що рідко змінюються. *Динамічні* системи виявлення сервісів орієнтовані на системи, в яких допустима
часта поява і зникнення сервісних компонентів. 

Найчастіше для реалізації сервіс-орієнтованої архітектури використовуються ***веб-сервіси*** – слабозв'язані програмні компоненти, що підтримують багатократне використання, які
семантично інкапсулюють окремі функціональні можливості і програмним чином доступні
по стандартних протоколах Інтернету. Веб-сервіси незалежні від платформи і мови
програмування, оскільки базуються на обміні даними в форматах XML, JSON.

Більшість веб-сервісів використовують HTTP для передачі повідомлень. Це дає значну
перевагу при розробці розподілених застосунків в масштабі Інтернет, оскільки зазвичай
брандмауери і проксі-сервери без обмежень пропускають HTTP-трафік, і в процесі взаємодії
не виникає несподіваних труднощів.

SOA передбачає наявність трьох основних учасників : постачальника сервісу, споживача сервісу і реєстру сервісів . Постачальник сервісу реєструє свої сервіси в реєстрі, а споживач звертається до реєстру із запитом на виявлення сервісу, після чого взаємодіє з ним.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

cloud Service {
    [Service Component]
}

cloud ServiceRegistry as "Service Registry" {
    [Service Registry Component]
}

cloud  Client {
    [Service Orchestrator]
}

[Service Component] .u.> [Service Registry Component]: over HTTP
[Service Component] <. [Service Orchestrator]: over HTTP
[Service Orchestrator] .u.> [Service Registry Component]: over HTTP


@enduml

</center>

Постачальник сервісу і його споживач виявляються незв'язаними - вони спілкуються за допомогою повідомлень. Оскільки інтерфейс повинен не залежати від платформи, то і технологія, використовувана для визначення повідомлень, також повинна не залежати від платформи. 

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant Client

participant SR as "Service Registry"

participant Service

Service -> SR : register
SR -> SR
SR --> Service
...

SR -> Service: heartbeat
SR <-- Service: health
...

Client -> SR: find
Client <-- SR: service endpoint
Client -> Service: request
Client <-- Service: response



@enduml

</center>


SOA не прив'язана до жорсткої методології
проектування, впровадження або управління ІТ-інфраструктурою. Вона обмежується лише
низкою принципів:
- *Розподілене проектування*. Рішення відносно внутрішніх особливостей
інформаційних систем приймаються різними групами людей, що мають власні організаційні,
політичні і економічні мотиви.
- *Постійність змін*. Окремі аспекти архітектури можуть зазнавати зміни у будь-який
момент часу.
- *Послідовне вдосконалення*. Локальне поліпшення компонентів системи повинне
призводити до вдосконалення усієї системи в цілому – до зростання сумарної корисності
компонентів того ж рівня, що і змінюваний, так само як і компонентів нижчого і більш високого

Процес перетворення бізнес-логіки в логіку додатків і реалізація сервісів на основі цих
вимог є процесом створення сервісно-орієнтованої інфраструктури для завдань
підприємства. 

При час реалізації власної інфраструктури бажано дотримуватися деяких основних підходів,
описаних нижче.

***Сервіси повинні підтримувати повторне використання***. SOA-системи повинні
підтримувати повторне використання усіх сервісів, незалежно від миттєвих вимог до їх
функціональних особливостей. Якщо при розробці системи постаратися максимально 
врахувати цю вимогу, то підвищуються шанси значно спростити процес рішення завдань, які
неодмінно з'являться в майбутньому, при розвитку системи. Також спочатку орієнтований на
повторне використання сервіс дозволяє уникнути розробки "обгортки", яка б підлаштовувала
старий сервіс для вирішення нових завдань. Оскільки сервіс – набір взаємопов'язаних операцій, логіка
кожної індивідуальної операції, що надається сервісом, повинна підтримувати повторне
використання.

***Сервіси повинні забезпечувати формальний контракт використання***. Контракт
сервісу надає наступну інформацію: кінцеву точку (service endpoint): адресу, по якій можна
звернутися до цього сервісу; усі операції, що надаються сервісом; усі повідомлення,
підтримувані кожною операцією; правила і характеристики сервісу і його операцій.

***Сервіси мають бути слабопов’язані***. Система сервісів є слабопов'язаною,
якщо сервіс може отримувати інформацію про інший сервіс, залишаючись незалежним від
внутрішньої реалізації логіки цього сервісу. Це досягається за допомогою використання
контрактів сервісів. Слабопов’язаність програмних компонентів, що лежить в основі SOA,
дозволяє значно спростити координацію розподілених систем і їх реконфігурацію. 

***Сервіси повинні абстрагувати внутрішню логіку***. Кожен сервіс повинен діяти як
"чорний ящик", що приховує свої деталі від навколишнього світу. Немає чіткого визначення,
який об'єм логіки повинен поміщатися в окремому сервісі. 

***Сервіси мають бути сумісні***. Сервіс може як самостійно реалізовувати логіку, так і
застосовувати інші сервіси для її реалізації. Сервіси мають бути спроектовані так, щоб
підтримувати можливість їх використання як елементи іншого сервісу. Принцип сумісності
не залежить від того, чи використовує сервіс для виконання своєї роботи інші сервіси. Як
приклад такої взаємодії сервісів виступає концепція оркестрації сервісів. В цьому випадку,
сервіс-орієнтований процес (який в принципі може бути визначений як композиція сервісів)
управляється сервісом батьківського процесу, який включає інші сервіси, що є учасниками
цього процесу. 

***Сервіси мають бути автономними***. Властивість автономності вимагає, щоб область
бізнес-логіки і ресурсів, використовуваних сервісом були обмежені явними межами. Це
дозволяє сервісу самому управляти усіма своїми процесами. Також це усуває залежність від 
інших сервісів, що звільняє сервіс від зв'язків, які можуть перешкоджати його застосуванню і
розвитку. Питання автономності – найбільш важливий аргумент при розподілі бізнес-логіки
на окремі сервіси. 

***Сервіси не повинні використовувати інформацію про стан.*** Сервіси повинні зводити
до мінімуму об'єм інформації про стан, і час, протягом якого вони його контролюють. 
Інформація про
стан – це певні дані, що характеризують поточну діяльність. Якщо сервіс несе
відповідальність за збереження стану протягом тривалішого часу, його здатність залишатися
доступним для інших клієнтів буде ускладнена. Незалежність від стану (statelessness)
дозволяє підвищити можливості масштабованості і повторного використання сервісів. 

***Сервіси повинні підтримувати виявлення.***  Метадані сервісу
повинні детально описати не лише загальну мету сервісу, але і функціональність, що
реалізовується його операціями. На рівні СОА виявлення характеризує здатність
архітектури забезпечити механізми пошуку, такі як реєстр або каталог. На рівні сервісу,
принцип виявлення відноситься до процесу проектування окремого сервісу, так щоб цей
сервіс настільки піддавався виявленню, наскільки це можливо.

## Архітектура, орієнтована на  події 

Архітектура, орієнтована на  події (Event-Driven Architectureб EDA) — шаблон архітектури програмного забезпечення, який призначений для створення подій, їх виявлення, споживання і реагування на них.

***Подія*** може бути визначена як важлива зміна стану системи або її компонентів, що потребує певної реакції. З формальної точки зору, те, що виробляється, публікується, поширюється, виявляється і споживається (як правило, асинхронно) є ***повідомленням***, яке називають сповіщенням про подію (або нотифікацією), а не самою подією, яка є зміною стану, що викликає появу повідомлення. Події не подорожують, вони просто відбуваються. 

Цей архітектурний шаблон може застосовуватися при проектуванні і реалізації застосунків і систем, які передають події між слабкозв'язаними компонентами програмного забезпечення і сервісами (службами).

EDA складається з ***емітерів*** подій (або агентів) і споживачів подій (або стоків). ***Стоки*** несуть відповідальність за здійснення реагування на подію. Реакція не завжди може бути повністю забезпечена самим стоком. Наприклад, стік, може бути відповідальним лише за фільтрацію, трансформацію і відправку повідомлення до іншого компонента, або він може забезпечити повністю самостійну реакцію на таку подію. Перша категорія стоків може бути заснована на традиційних компонентах, таких як проміжне програмне забезпечення, орієнтоване на обробку повідомлень (Message Oriented Middleware, MOM), в той час, як друга категорія стоків (самостійна реакція в режимі онлайн) може вимагати більш придатної платформи (фреймворку) для виконання транзакцій.

EDA дозволяє розробляти застосунки і системи, які  можуть пристосовуються до непередбачуваних і асинхронних середовищ.

EDA може доповнювати сервісно-орієнтовану архітектуру SOA, оскільки сервіси (служби) можуть бути активовані тригерами, які ініціюються при настанні подій.

Зазвичай повідомлення складається з двох частин: заголовка та тіла. Заголовок може включати в себе інформацію таку як, наприклад, назва події, часова мітка події і тип події. Тіло — це частина, яка описує факт, що стався в дійсності. Тіло не слід плутати з шаблоном або логікою, яка може бути застосована як реакція на саме повідомлення.
Наприклад, така структура повідомлення використовується в проекті [Сloudevents](https://cloudevents.io/), мета якого уніфікація способів визначення повідомлень та досягнення широких можливостей інтеграції ресурсів в глобальних розподлілених системах.

```json
{
  "specversion":"0.3",
  "type":"com.github.pull.create",
  "source":"https://github.com/cloudevents/spec/pull/123",
  "id":"70d3c768-63f8-40e7-aa9d-d197d530586b",
  "time":"2019-07-04T17:31:00Z",
  "datacontenttype":"application/json",
  "data":{
    "much":"wow"
  },
  "myextension" : {
    "some" : "thing"
  }
}
```


EDA складається з чотирьох логічних рівнів (шарів). Вона починається з виявлення факту, його технічного подання у формі повідомлення і закінчується непустою множиною реакцій на цю подію:
- ***Генератор подій***. Першим логічним шаром є генератор подій, який виявляє факт і представляє цей факт подією. Оскільки фактом може бути практично все, що може бути сприйнято, то ним може бути і генератор подій. Наприклад, генератором може бути клієнт електронної пошти, система електронної комерції або певний тип датчика. Перетворення різних даних, отриманих від датчиків, в єдину стандартизовану форму повідомлень є основною проблемою при розробці та реалізації цього шару. Однак, враховуючи, що повідомлення є строго декларативним, можна легко застосовувати будь-які операції трансформації, тим самим усуваючи необхідність забезпечення високого рівня стандартизації.
- ***Канал подій***. Канал подій — це механізм, через який повідомлення від генератора подій передається до обробника подій (стоку). Це може бути з'єднання TCP/IP або вхідний файл будь-якого типу (простий текст, формат XML, e-mail тощо). В один і той же час може бути відкрито кілька каналів подій. Оскільки обробник подій повинен працювати в режимі, наближеному до реального часу, канали подій зчитуються асинхронно. Події зберігаються в черзі каналу, очікуючи наступної обробки механізмом обробки подій.
- ***Механізм обробки подій***. Механізм обробки подій є місцем, де подія ідентифікується і вибирається відповідна реакція на нього, яка потім виконується. Це також може призвести до породження низки дій.
- ***Післядія***.  Наслідки події можуть проявитись багатьма різними способами і у різноманітних формах (наприклад, відправлення комусь повідомлення електронною поштою, вивід деякого попередження на екран, тощо.


<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant Producer

participant MOM as "Event Processing"

participant Consumer

Producer -> MOM : primary event
MOM -> MOM: Event Processing
MOM -> Consumer: processed event
Consumer -> Consumer: action

@enduml

</center>

Є три основні стилі оброблення повідомлень: простий, потоковий і складний. Часто всі ці три стилі комбінуються в EDA-системах.

***Просте оброблення повідомлень*** стосується визначених подій (notable events) - простих подій, для яких визначена післядія. Просте оброблення зазвичай використовується для управління потоком робіт в реальному часі, скорочуючи тим самим час затримки і вартість робіт.

При ***обробленні потоку подій*** прості події перевіряються на те, чи є вони визначеними, і, якщо післядія відома, передаються інформаційним підписникам. Обробка потоку подій зазвичай використовується для моніторингу та управління потоком інформації в реальному часі і на рівні підприємства, що дозволяє своєчасно приймати рішення.

***Оброблення складних подій*** дозволяє за шаблонами простих і визначених подій проводити аналіз того, чи сталася складна подія. Обробка складних подій полягає в оцінюванні взаємного впливу подій і в наступному виконанні дій. При цьому, типи подій можуть перетинатись, а події можуть виникати протягом тривалого періоду часу. Кореляція подій може бути причинною, тимчасовою або просторовою. Оброблення складних подій вимагає використання складних інтерпретаторів подій, визначення і підбору шаблонів подій, а також відповідних кореляційних методів. Оброблення складних подій зазвичай використовується для виявлення і реагування на аномальну поведінку, загрози і можливості у бізнесі.

***Advanced Message Queuing Protocol, AMQP*** —  відкритий протокол для передачі повідомлень між компонентами системи забезпечує можливості реалізації всіх стилей оброблення повідомлень. Основна ідея полягає в тому, що окремі підсистеми
можуть обмінюватися даними через AMQP-брокер, який здійснює маршрутизацію, можливо забезпечує гарантоване доставлення
повідомлень, розподілення потоків повідомлень, реалізовувати підписку на необхідні типи повідомлень.

В AMQP використовуються наступні поняття.

***Повідомлення (message)*** — одиниця даних, що передаються. Основна його частина ніяк не інтерпретується сервером, до повідомлення можна приєднувати структуровані заголовки. 

***Точка обмена (exchange)***, в яку відправляються повідомлення. Точка обміну розподіляє повідомлення в одну або декілька черг. Вона не зберігає повідомлення. Точки обміну бувають трьох типів:
- ***fanout*** — повідомлення передається у всі приєднані черги;
- ***direct*** — повідомлення передається в чергу з ім'ям, яке співпадає з ключем маршрутизації, який вказується під час відправлення повідомлення;
- ***topic*** — повідомлення передається в черги, для яких співпадає маска для ключа маршрутизації, наприклад, ```app.notification.sms.#``` — в чергу будуть доставлені повідомлення, відправлені з ключами, що починаються з ``` app.notification.sms```.
- ***Черга (queue)*** — сховище повідомлень, які зберігаються, поки не будуть забрані клієнтом. Клієнт забірає повідомлення з одної або декількох черг.

***Producer*** - застосунок, який публікує повідомлення в exchange. Всі повідомлення відправляються в одну точку обміну, де перевіряються та перерозподіляються в черги.

***Consumer*** - застосунок, який отримує повідомлення з черги. Чегра повідомлень повинна бути готова до старта застосунку і повинна бути прив'язана до нього. Споживач може створювати.видаляти черги повідомлень, визначати спосіб заповннея черг за допомогою правил (bindings), вибирати різні точки обміну.

Коли застосунок створює чергу, може бути вказані:
- ```name``` - якщо не вказано, сервер сам обирає ім'я та відправляє його застосунку;
- ```exclusive``` - якщо цей параметр встановлено, черг існує поки існує поточне з'єднання. Після розриву з'єднання черга видаляється;
- ```durable``` - якщо встановлено, черга існує і активна після перезавантаження сервера. Однак черга може загубити повідомлення, що передавалися під час з'єднання.

Більшість інтеграційних архітектур використовують базову функціональність:
- базовий (default) exchange для відправників (producers) повідомлень;
- базовый binding для черг, який сортує повідомлення на основі співпадіння ім'я черги та ключа маршрутизації.

В результаті базовий binding дозволяє producer відправляти повідомлення начебто безпосередньо до черги, таким чином він емулює найпростішу схему відправлення повідомлень, яку розробники очікують від традиційного middleware. Базовый binding дозволяє використовувати AMQP без конкретного знання роботи механізмів binding и exchange.

Типові схеми взаємодії компонентів розподіленої системи з AMQP-брокером через AMQP-клієнт зображені нижче.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant Producer
participant amqp as "AMQP client"
participant Connection
participant Channel

participant AMQP as "AMQP broker"

Producer -> amqp: connect
amqp -> AMQP
amqp <-- AMQP
create Connection
amqp -> Connection
Producer -> Connection : createChannel
create Channel
Connection -> Channel
Producer -> Channel: assertQueue
Channel -> AMQP: queue params
Channel <-- AMQP
Producer -> Channel: sendToQueue
Channel -> AMQP: message


@enduml

</center>

Застосунок ```Producer```, використовуючи ```AMQP client```, здійснює з'єднання з ```AMQP broker```, створює ```Channel```, через який взаємодіє з чергами повідомлень.


<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml
participant AMQP as "AMQP broker"
participant Channel
participant Connection
participant amqp as "AMQP client"

participant Consumer
participant Handler


Consumer -> amqp: connect
amqp -> AMQP
amqp <-- AMQP
create Connection
amqp -> Connection
Consumer -> Connection : createChannel
create Channel
Connection -> Channel
Consumer -> Channel: assertQueue
Channel -> AMQP: queue params
Channel <-- AMQP
create Handler
Consumer -> Handler
Consumer -> Channel: consume
Channel <- AMQP: message
Channel -> Handler
Handler -> Handler: handle event
Channel <- Handler: ask
Channel -> AMQP: ask
AMQP -> AMQP: delete message 



@enduml

</center>

З боку споживача майже так само створюється з'єднання, канал, підключення до черги. Слід зауважити, що в схемі взаємодії з підтвердженням отримання повідомлення вони видаляються на боці сервера лише після отримання підтвардження від споживача. Якщо підтвердження відсутнє, можлива повторна вибірка повідомлень після перезавантаження споживача.

## Мікросервісна архітектура 

***Мікросервіси*** — архітектурний стиль, за яким застосунок будується як сукупність невеличких сервісів, кожен з яких працює у своєму власному процесі та спілкується з рештою, використовуючи прості та швидкі протоколи передачі даних. Ці сервіси будуються навколо бізнес-потреб і розгортаються незалежно один від одного з використанням зазвичай повністю автоматизованого середовища. Існує абсолютний мінімум централізованого керування цими сервісами. Самі по собі вони можуть бути написані з використанням різних мов програмування і технологій зберігання даних.

Переваги, які надає цей підхід для розроблення надскладних інформаційних систем великою кількістю невеличких команд розробників, є настільки переконливими, що такі великі корпоративні гравці як Amazon, Netflix або eBay впровадили його для розробки  своїх систем.

Існують певні відмінності між мікросервісною архітектурою і SOA. В першу чергу, основна відмінність зводиться до сфери застосування. SOA орієнтована на корпоративну сферу, а архітектура мікросервісів  - на розробку застосунків.

***Повторне використання***. У SOA повторне використання інтеграцій є основною метою, а на рівні підприємства прагнення до певного рівня повторного використання має істотне значення. Повторне використання та спільний доступ до компонентів в архітектурі SOA підвищує масштабованість та ефективність. В архітектурі мікросервісів створення компонента мікросервіса, яке повторно використовується під час виконання у всьому додатку, призводить до виникнення залежностей. Вважається за краще повторно використовувати код, дублювати дані, щоб покращити роз’єднання.

***Взаємодія сервісів***. Служби багаторазового використання в SOA доступні по всьому підприємству з використанням переважно синхронних протоколів, таких як  RESTful AP. Однак  у  додатку для мікросервісів синхронні виклики вводять залежності в режимі реального часу, що призводить до втрати стійкості. Ці залежності також можуть викликати затримку, що впливає на продуктивність. У додатку для мікросервісів перевагу віддають моделям взаємодії, заснованим на асинхронному зв’язку.

***Дублювання даних***. Чітка мета надання послуг у SOA полягає в тому, щоб усі програми синхронно отримували та змінювали дані безпосередньо у своєму первинному джерелі, що зменшує потребу у підтримці складних шаблонів синхронізації даних. У додатках для мікросервісів в ідеалі кожна мікросервіс має локальний доступ до всіх даних, необхідних для забезпечення її незалежності від інших мікросервісів - і навіть від інших програм - навіть якщо це означає певне дублювання даних в інших системах. 

***Декомпозиція системи***. Архітектури мікросервісів складаються з вузькоспеціалізованих служб, кожна з яких призначена для виконання одного завдання. Послуги, які складають SOA, можуть варіюватися від невеликих спеціалізованих послуг до послуг у масштабі всього підприємства.

Таким чином, для цих сервісів характерні три властивості:
- кожен з них може мати власний стек, що включає базу і модель даних;
- вони взаємодіють один з одним за допомогою поєднання REST API , потоків подій і брокера повідомлень;
- модулі застосунку підбираються виходячи з конкретних потреб бізнесу.

З точки зору бізнесу і організаційних завдань переваги мікросервісов зводяться до 
легкості оновлення коду, різні команди можуть використовувати різні стеки для різних модулів,
компоненти можуть масштабуватися незалежно один від одного.

Розділення системи на мікросервіси - це непросте завдання, алеіснує ряд перевірених стратегій, які можуть допомогти:
- Декомпозиція за можливостями бізнесу та визначення послуг, що відповідають можливостям бізнесу.
- Декомпозиція за допомогою дієслів або варіантів використання.
- Декомпозиція за допомогою іменників або ресурсів. Сервіси відповідають за всі операції над сутностями/ресурсами певного типу.

В ідеалі кожна служба повинна мати лише невеликий набір обов’язків. Є сенс застосувати принцип єдиної відповідальності до проектування послуг.

З точки зору того, яким чином клієнти отримують доступ до сервісів, існує декілька ключових питань.

***Деталізованість API***, що надаються мікросервісами, часто відрізняється від того, що потрібно клієнту. Мікросервіси зазвичай забезпечують дрібнозернисті API, що означає, що клієнтам потрібно взаємодіяти з декількома службами. 

***Різним клієнтам потрібні різні дані***. Наприклад, версія веб-переглядача сторінки з інформацією про продукт настільного комп’ютера зазвичай є більш складною, ніж її мобільна версія.

Служби можуть використовувати ***різноманітний набір протоколів***, деякі з яких можуть бути не зручними для Інтернету.

Кількість екземплярів служби та їх розташування (хост+порт) змінюються динамічно. Розподіл на служби може змінюватися з плином часу і повинен бути прихований від клієнтів.

Ці проблеми вирішуються за допомогою шлюзу API, який є єдиною точкою входу для всіх клієнтів. Шлюз API обробляє запити одним із двох способів. Деякі запити просто передаються за допомогою проксі/маршрутизації до відповідної служби.  Для інших запитів - можливо перетворює протоколи та координує декілька сервісів.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>


@startuml


node SN as "Server Node" {
 [WEB App]
}

node MN as "Mobile Node" {
 [Mobile App]
}

node E as "3rd party client" {
 [External Client App]
}


node APIG as "API Gateway Node" {
    [WEB API Gateway]
    [Mobile API Gateway]
    [Public API Gateway]
}

node D1 as "Deployment 1" {
    [RESTfull Service 1]
}

node D2 as "Deployment 2" {
    [RESTfull Service 2]
}

node D3 as "Deployment 3"{
    [AMQP Service]
}

[WEB App] ..> [WEB API Gateway]

[Mobile App] ..> [Mobile API Gateway]

[External Client App] ..> [Public API Gateway]


[WEB API Gateway] ..> [RESTfull Service 1]
[WEB API Gateway] ..> [RESTfull Service 2]
[WEB API Gateway] ..> [AMQP Service]

[Mobile API Gateway] ..> [RESTfull Service 1]
[Mobile API Gateway] ..> [RESTfull Service 2]
[Mobile API Gateway] ..> [AMQP Service]

[Public API Gateway] ..> [RESTfull Service 1]
[Public API Gateway] ..> [RESTfull Service 2]
[Public API Gateway] ..> [AMQP Service]

@enduml


</center>


Для отримання результатів з декількох сервісів шлюз API реалізує API Composer

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml


query -- [API Composer]

[API Composer] -- query1
[API Composer] -- query2
[API Composer] -- query3


query1 -- [service 1]
query2 -- [service 2]
query3 -- [service 3]

@enduml

</center>

API Composer викликає служби, які володіють даними, і виконує з'єднання результатів.

Якщо запит клієнта пов'язаний з зміною стану бізнес-сутностей, що не мають єдиного представлення, оскільки кожен з сервісів має власну базу даних і працює з обмеженим контекстом бізнес-сутностей, необхідно реалізовувати механізми розподілених транзакцій.

Одним з способів реалізації розподілених транзакцій є сага, що складається з локальних транзакцій в кожному задіяному сервісі.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml
participant S1 as "Service 1"
participant S2 as "Service 2"
participant S3 as "Service 3"


S1 -> S1: local transaction
S1 -> S2: message
S2 -> S2: local transaction
S2 -> S3: message
S3 -> S3: local transaction
@enduml

</center>

Існує два способи координації саг:
- ***Хореографія*** - кожна локальна транзакція публікує події, які ініціюють локальні транзакції в інших сервісах.
- ***Оркестрування*** - використовується спеціальний оркестратор, що повідомляє учасникам, які локальні транзакції виконувати.

Розглянемо приклади для завдання створення замовлення з перевіркою ліміту кридита для замовника.

***Сага на основі хореографії***

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml
actor Client
participant OS as "Order Service"
participant O as "Order"

box "Message Broker" 
participant OE as "Order events\n <<Channel>>"
participant CE as "Customer events\n <<Channel>>"
end box

participant CS as "Customer Service"


Client -> OS
create O
OS -> O: pending
OS -> OE: order created
OE -> CS
CS -> CS: check credit limit
CS -> CE: credit reserved
CE -> OS
OS -> O: approve


@enduml

</center>

```Order Service``` отримує запит та створює ```Order``` в стані ```PENDING```. Потім публікує повідомлення ```Order Created```.
```Customer Service``` перевіряє перевищення ліміту та публікує відповідне повідомлення. ```OrderService``` підтверджує ```Order```.


***Сага на основі оркестрування***

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml
actor Client
participant OS as "Order Service"
participant Orc as "Saga\norchestrator" #ffeaea
participant O as "Order"

box "Message Broker" 
participant OE as "Customer service\ncommands\n<<Channel>>" #ffeaea
participant CE as "Orchestrator replies\n<<Channel>>" #ffeaea
end box

participant CS as "Customer Service"


Client -> OS
create Orc
OS -> Orc
create O
Orc -> O: pending
Orc -> OE: <font color=red><b> reserve credit
OE -> CS
CS -> CS: <font color=red><b> reserve credit impl
CS -> CE: credit reserved
CE -> Orc
Orc -> O: approve


@enduml

</center>

```Order Service``` отримує запит та створює ```Saga orchestrator```. Він створює ```Order``` в стані ```PENDING``` та посилає команду резервування кредиту. ```Customer Service``` резервує кредит та публікує відповідь. ``Saga orchestrator``` підтверджує ```Order```.

Клієнт, який ініціює сагу,що реалізується асинхронним потоком, використовуючи синхронний запит (наприклад, ```HTTP POST /orders```), повинен мати можливість визначити її результат. Існує кілька варіантів:
- Сервіс надсилає відповідь, як тільки сага завершується, наприклад, коли вона отримує подію ```OrderApproved``` 
або ```OrderRejected```.
- Сервіс надсилає відповідь (наприклад, ```orderID```) після ініціювання саги, а клієнт періодично опитує (
наприклад ```GET /orders/{orderID}```), щоб визначити результат.
- Сервіс надсилає відповідь (наприклад, ```orderID```) після ініціації саги, а потім надсилає клієнту подію (наприклад, websocket, веб-хук тощо) після завершення саги.

Склад сервісів в мікросервісній архітектурі постійно оновлюється і є доволі мінливим, особливо у випадку динамічноно масштабування, коли сервіси можуть перерозташовуватись на різних обчислювальних вузлах (типова ситуація для хмарної інфраструктури). Тому вирішення завдання виявлення ресурсів є надзвичайно важливим.

Можна використати різні схеми виявлення ресурсів.

***Виявлення ресурсів на клієнтському боці*** передбачає, що під час надсилання запиту до служби клієнт отримує місцезнаходження екземпляра служби, запитуючи реєстр сервісів, який знає розташування всіх екземплярів сервісу.

***Виявлення ресурсів на серверному боці*** передбачає, що під час надсилання запиту до служби клієнт робить запит через маршрутизатор, який працює у добре відомому місці. Маршрутизатор запитує реєстр сервісів, який може бути вбудований у маршрутизатор, і пересилає запит до доступного екземпляра служби.

***Реєстр сервісів*** - це база даних сервісів та їх розташування. Екземпляри служби реєструються в реєстрі сервісів під час запуску та скасовують регістрацію після завершення роботи. Клієнт служби та/або маршрутизатори запитують реєстр сервісів, щоб знайти доступні екземпляри. Реєстр сервісів може викликати API перевірки справності екземпляра сервісу, щоб перевірити його здатність обробляти запити (heart-beating).

Зазвичай екземпляр сервісу відповідає за реєстрацію себе в реєстрі. При запуску екземпляр сервісу реєструється (хост та IP -адреса) у реєстрі і стає доступним для виявлення. Зазвичай сервіс повинен періодично поновлювати реєстрацію, щоб реєстр знав, що він все ще живий. Після завершення роботи екземпляр служби скасовує реєстрацію з реєстру служб.

Схема взаємодії для механізму виявлення ресурсів з використанням обміну повідомленнями наведена нижче.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml
participant AG as "API Gateway"


participant SR as "Service Registry"


participant SAE as "Service A Entity"

box "Message Broker" 
participant SHE as "Service Health\nevents\n<<Channel>>"
end box


participant CICD as "CI/CD"

create SAE
CICD -> SAE: deploy, start

group Service self registration

SAE -> SHE: Service A Entity starts at {host}

SHE -> SR
SR -> SR: add Service A Entity
SR -> SR: start timeout

end
...

group Service Health Monitoring

SAE -> SHE: Service A Entity health
SHE -> SR
SR -> SR: restart timeout
end
...
group Service Discovery
AG -> SR: Service A
AG <-- SR: Service A endpoint
AG -> SAE: Request
end
...

group When service health events is unavailable [timeout callback]
SR -> SR: delete Service A Entity
end


@enduml

</center>

Коли в системі присутні декілька екземплярів сервісу, функції балансувальника навантаження можуть бути інкапсульовані в реєстрі сервісів або в шлюзі API.