---
title  Реалізація обміну повідомленнями за допомогою RabbitMQ
---

# Реалізація обміну повідомленнями за допомогою RabbitMQ 

RabbitMQ - найпоширеніший брокер повідомлень з відкритим кодом.
З десятками тисяч користувачів, RabbitMQ є одним з найпопулярніших посередників повідомлень з відкритим кодом, який використовується у всьому світі для невеликих стартапів та великих підприємств.

RabbitMQ є легким і простим у розгортанні. Він підтримує декілька протоколів обміну повідомленнями. RabbitMQ можна розгортати у розподілених та об’єднаних конфігураціях для задоволення масштабних вимог високої доступності.

Для нашої реалізації скористамося хмарним сервісом [CloudAMQP](https://www.cloudamqp.com/), який є SaaS та надає фунціональність брокера повідомлень з підтримкою протоколу AMQP.

Для цього треба створити власний профіль, скориставшись власним Google Account

<center>
    <img src="/13-01.jpg" style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    ">
</center>

Вибрати безкоштовний план 

<center>
    <img src="/13-02.jpg" style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    ">
</center>

Вибрати майданчик для розташування сервісу та створити його екземпляр. Тепер маємо доступ до брокера повідомлень, його AMQP URL ми будемо використовувати в наших програмах.

<center>
    <img src="/13-03.jpg" style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    ">
</center>

Підготуємо проект та встановимо необхідні залежності. Файл ```package.json``` має наступний вигляд

```json

{
  "name": "eda",
  "version": "1.0.0",
  "description": "Event Driven Arch with RabbitMQ",
  "dependencies": {
    "amqplib": "latest",
    "lodash": "^4.17.21",
    "moment": "^2.29.1",
    "uuid": "^8.3.2"
  }
}

```

Серед цих залежностей ключовою є [amqplib](https://www.npmjs.com/package/amqplib), яка забезпечує взаємодію клієнтів (продюсерів та споживачів) з брокером повідомлень RabbitMQ.

## Реалізація простої взаємодії з використанням черг повідомлень

 Ми напишемо дві невеликі програми на Javascript; продюсер, який надсилає одне повідомлення, і споживач, який отримує повідомлення і роздруковує їх.

 Типова схема використання виглядає наступним чином: створюємо з'єднання, потім створюємо канал, оголошуємо чергу для надсилання повідомлень; тоді ми можемо публікувати повідомлення в ній.

 ```js
const amqp = require("amqplib")

...

    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assertion = await channel.assertQueue(config.queue.PRIMARY)
    
    await channel.sendToQueue(config.queue.PRIMARY, Buffer.from(JSON.stringify(message)))
 
...

 ```

Після окінчення взаємодії ми повинні закрити канал та з'єднання

 ```js
const amqp = require("amqplib")

...

    await channel.close()
    await connection.close()
     
...

```

Як бачимо більшість методів ```connection```та ```channel``` є асинхронними.

Створимо файл конфігурації ```./src/config.js```, який містить AMQP URL та налаштування (імена) для черг та обмінників:

```js

module.exports = {
    AMQP_CONNECTION_URL: '<your AMQP URL>',
    queue: {
        PRIMARY: 'primary',
        TASK: 'task_queue',
        RPC:'rpc'
    },
    exchange: {
        LOGS: 'logs',
        DIRECT: 'direct_logs',
        TOPIC: 'topic_logs'
    }
}

```

Тепер створимо файл для простого продюсера ```./src/simple-producer```

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let message = {
      at: new Date(),
      text: "Message from producer"
    }

    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assertion = await channel.assertQueue(config.queue.PRIMARY)
    if( assertion ){
      let send = await channel.sendToQueue(config.queue.PRIMARY, Buffer.from(JSON.stringify(message)))
      if(send) log(`Simple Producer send message "${message}"`) 
    }
    
    await channel.close()
    await connection.close()
    
}

run()

```

Бібліотеку [moment.js]() будемо використовувати для оформлення часових міток повідомлень. Для цього визначимо функцію ```log```.


Визначаємо асинхронну функцію ```run```, яка здійснює всю небхідну роботу. Потім її викликаємо.

Налаштування вибираємо з об'єкту конфігурації ```config```. Діємо за стандартною схемою: ***з'єднання  > канал > черга > повідомлення***. Після відправлення повідомлення закриваємо канал та з'єднання.

В якості повідомлення можна відправити будь-яку інформацію, проте вона повинна серіалізуватися в потік байтів. Зрозуміло, що на іншому боці (у споживача) потрібно застосувати зворотнє перетворення. Наприклад, наше повідомлення ```message``` є об'єктом; для його відправлення в якості повідомлення ми його серіалізуємо в рядок та перетворюємо у потік байтів 

```js {5}
 
 ...
 channel.sendToQueue(
    config.queue.PRIMARY, 
    Buffer.from(JSON.stringify(message))
  )
 ... 


```

Створимо файл споживача повідомлень ```./src/simple-consumer.js```

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    
    await channel.assertQueue(config.queue.PRIMARY)
    
    channel.consume(config.queue.PRIMARY, 
        msg => {
            log(`Received ${JSON.stringify(JSON.parse(msg.content.toString()), null, " ")}`);
        }, 
        { noAck: true }
    )

}

run()


```

Так само, як і для продюсера, ми створюємо з'єднання, канал і чергу, проте визначаємо слухача черги, який реагує на доставлення повідомлення


```js

... 

    channel.consume(config.queue.PRIMARY, 
        msg => {
            log(`Received ${JSON.stringify(JSON.parse(msg.content.toString()), null, " ")}`);
        }, 
        { noAck: true }

...


```

Саме повідомлення знаходиться в ```msg.content``` у вигляді послідовності байтів. Ми виконуємо зворотнє перетворення до того, що виконувалося в продюсері, та відновлюємо об'єкт повідомлення.

Для перевірки роботи обміну повідомленнями треба створити дві консолі та запустити в першій ```node ./src/simple-producer```, а в другій ```node ./src/simple-consumer```

Вивід в консолі продюсера

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/simple-producer                                                               
2021.08.23 14:53:03: Simple Producer send message "{"at":"2021-08-23T11:53:02.448Z","text":"Message from producer"}"     

```

Вивід в консолі споживача

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/simple-consumer                                                               
2021.08.23 14:54:02: Received { 
  "at": "2021-08-23T11:53:02.448Z",                                                               
  "text": "Message from producer"                                                                   
}                     


```


Слід зауважити, що крім ```msg.content``` у повідомленні можна передати додаткові властивості, доступ до яких здійснюється через
```msg.properties```. Одним з таких є ```msg.properties.contentType```, що містить MIME-тип повідомлення. Ця властивість використовується продюсерами, щоб повідомити споживачів, яким чином вони можуть десеріалізувати повідомлення. Сам брокер та клієнтська бібліотека не обробляють ці властивості ніяк. Тобто, при надсиланні повідомлення слід його перетворювати в послідовність байтів незалежно від встановленого ```msg.properties.contentType```. При отриманні повідомлення можна спиратися на значення ```msg.properties.contentType``` для вірної десеріалізації повідомлення.

Таким чином, використовуючи спільну чергу, ми реалізували взаємодію продюсера та споживача за допомогою обміну повідомленнями.

## Реалізація черги завдань

Основна ідея робочих черги завдань полягає у тому, щоб уникнути негайного виконання ресурсомісткого завдання і не чекати його завершення. Натомість ми плануємо виконання завдання пізніше. Ми інкапсулюємо завдання як повідомлення і надсилаємо його до черги. Робочий процес, що працює у фоновому режимі, викличе завдання та врешті-решт виконає його. Коли ви керуєте багатьма працівниками, завдання будуть розподілені між ними.

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant TG as "Service"

box "Message Broker" 
participant TQ as "Task Queue\n<<Channel>>"
end box


participant W1 as "Task Worker 1"
participant W2 as "Task Worker 2"

[-> TG : request 1
TG -> TQ: task 1
[<-- TG: status 200
[-> TG : request 2
TG -> TQ: task 2
[<-- TG: status 200

TQ -> W1: task 1
activate W1

TQ -> W2: task 2


activate W2

...

@enduml

</center>

Ця концепція особливо корисна у веб-додатках, де неможливо виконати складне завдання під час короткого вікна запиту HTTP.


Створимо файл ```./src/task-generator.js```, який імітує отримання потоку запитів та генерацію потоку завдань

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
        
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assertion = await channel.assertQueue(config.queue.TASK)
    if( assertion ){
        for(let i=0; i<10; i++) {
            let message = {
                name:`Task ${i}`,
                at: new Date(),
                duration: Math.round(Math.random()*1000)
            }
            let send = await channel.sendToQueue(config.queue.TASK, Buffer.from(JSON.stringify(message)))
            if(send) log(`Send task "${JSON.stringify(message)}"`)   
        }
    }
    
    await channel.close()
    await connection.close()
    
}

run()


```

Після створення черги генератор завдань генерує 10 завдань з випадковим часом виконання та передає їх в чергу. Після чого закриває канал та з'єднання.

Створимо файл ```./src/task-worker.js``` для працівника, що вирішує завдання

```js


const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    
    await channel.assertQueue(config.queue.TASK)

    
    channel.consume(config.queue.TASK, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`Received ${JSON.stringify(task, null, " ")}`);
            setTimeout(() => {
                log(`Complete task "${task.name}"`);
                channel.ack(msg);
            }, task.duration)
        }, 
        { noAck: false }
    )

}

run()

```

Обробник повідомлень здійснює затримку ```task.duration``` та повідомляє про завершення завдання. Після чого підтверджує отримання повідомлення: ```channel.ack(msg)```, яке ініціює видалення його з черги завдань. Для використання можливості отримання повідомлень з підтвердженням у виклику ```channel.consume``` треба передати налаштування ```{ noAck: false }```.

Виконання завдання може зайняти кілька секунд. Що станеться, якщо один із споживачів розпочне довге завдання і помре, виконавши його лише частково? Як тільки RabbitMQ доставляє повідомлення споживачеві при ```{ noAck: true }```, він негайно позначає його для видалення. Тобто, якщо ви вб'єте працівника, ми втратимо повідомлення, яке він обробляє. Ми також втратимо всі повідомлення, які були надіслані цьому конкретному працівнику, але ще не були оброблені.

Щоб переконатися, що повідомлення ніколи не втрачається, RabbitMQ підтримує підтвердження повідомлень. Споживач надсилає ack, щоб повідомити RabbitMQ про те, що певне повідомлення було отримано, оброблено і що RabbitMQ може його видалити.

Якщо споживач помирає (його канал закрито, з'єднання закрито або з'єднання TCP втрачено) без надсилання ack, RabbitMQ знову поставить його в чергу. Якщо в цей час є інші споживачі, RabbitMQ передасть ці повідомлення іншому споживачеві. Таким чином ви можете бути впевнені, що жодне повідомлення не пропаде, навіть якщо працівники час від часу вмирають.

Будемо використовувати 3 консолі: одну - для генератора завдань, дві інші для працівників.

Спочатку запустимо одного працівника ```node ./src/task-worker``` , потім - генератор завдань ```node ./src/task-generator```

В консолі генератора завдань маємо

```bash


D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-generator
2021.08.23 16:48:01: Send task "{"name":"Task 0","at":"2021-08-23T13:48:01.030Z","duration":691}"
2021.08.23 16:48:01: Send task "{"name":"Task 1","at":"2021-08-23T13:48:01.036Z","duration":335}"
2021.08.23 16:48:01: Send task "{"name":"Task 2","at":"2021-08-23T13:48:01.037Z","duration":597}"
2021.08.23 16:48:01: Send task "{"name":"Task 3","at":"2021-08-23T13:48:01.038Z","duration":625}"
2021.08.23 16:48:01: Send task "{"name":"Task 4","at":"2021-08-23T13:48:01.038Z","duration":950}"
2021.08.23 16:48:01: Send task "{"name":"Task 5","at":"2021-08-23T13:48:01.039Z","duration":62}"
2021.08.23 16:48:01: Send task "{"name":"Task 6","at":"2021-08-23T13:48:01.039Z","duration":947}"
2021.08.23 16:48:01: Send task "{"name":"Task 7","at":"2021-08-23T13:48:01.040Z","duration":334}"
2021.08.23 16:48:01: Send task "{"name":"Task 8","at":"2021-08-23T13:48:01.040Z","duration":205}"
2021.08.23 16:48:01: Send task "{"name":"Task 9","at":"2021-08-23T13:48:01.040Z","duration":273}"


```

Консоль працівника виглядає наступним чином

```bash
D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-worker                                                                   
2021.08.23 16:48:01: Received {                                      
 "name": "Task 0",                                                                                  
 "at": "2021-08-23T13:48:01.030Z",                                                               
 "duration": 691                                                                                 
}
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 1",                                                                                  
 "at": "2021-08-23T13:48:01.036Z",                                                               
 "duration": 335                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 2",                                                                                  
 "at": "2021-08-23T13:48:01.037Z",                                                               
 "duration": 597                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 3",                                                                                  
 "at": "2021-08-23T13:48:01.038Z",                                                               
 "duration": 625                                                                                 
}
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 4",                                                                                  
 "at": "2021-08-23T13:48:01.038Z",                                                               
 "duration": 950                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 5",                                                                                  
 "at": "2021-08-23T13:48:01.039Z",                                                               
 "duration": 62                                                                                  
} 
2021.08.23 16:48:01: Complete task "Task 5"                                            
2021.08.23 16:48:01: Received {                                                        
 "name": "Task 6",                                                                                  
 "at": "2021-08-23T13:48:01.039Z",                                                               
 "duration": 947                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 7",                                                                                  
 "at": "2021-08-23T13:48:01.040Z",                                                               
 "duration": 334                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 8",                                                                                  
 "at": "2021-08-23T13:48:01.040Z",                                                               
 "duration": 205                                                                                 
} 
2021.08.23 16:48:01: Received {                                                                    
 "name": "Task 9",                                                                                  
 "at": "2021-08-23T13:48:01.040Z",                                                               
 "duration": 273                                                                                 
} 
2021.08.23 16:48:01: Complete task "Task 8"                                            
2021.08.23 16:48:01: Complete task "Task 1"                                            
2021.08.23 16:48:01: Complete task "Task 9"                                            
2021.08.23 16:48:01: Complete task "Task 7"                                            
2021.08.23 16:48:01: Complete task "Task 0"                                            
2021.08.23 16:48:01: Complete task "Task 2"                                            
2021.08.23 16:48:01: Complete task "Task 3"                                            
2021.08.23 16:48:02: Complete task "Task 4"                                            
2021.08.23 16:48:02: Complete task "Task 6"

```

Як бачимо, працівник отримує одразу 10 повідомлень, після чого виконує одне за одним відповідні завдання.

Тепер запустимо два працівника (кожний в своїй консолі) та генератор (в коді зменшимо кількість інформації, що виводиться на
консоль)

Працівник 1:

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-worker
2021.08.23 16:58:27: Received Task 0                                                          
2021.08.23 16:58:27: Received Task 2                                                          
2021.08.23 16:58:27: Received Task 4                                                          
2021.08.23 16:58:27: Received Task 6                                                          
2021.08.23 16:58:27: Received Task 8                                                          
2021.08.23 16:58:27: Complete task "Task 4"                                            
2021.08.23 16:58:27: Complete task "Task 0"                                            
2021.08.23 16:58:27: Complete task "Task 6"                                            
2021.08.23 16:58:27: Complete task "Task 8"                                            
2021.08.23 16:58:28: Complete task "Task 2"

```

Працівник 2:

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-worker
2021.08.23 16:58:27: Received Task 1                                                          
2021.08.23 16:58:27: Received Task 3                                                          
2021.08.23 16:58:27: Received Task 5                                                          
2021.08.23 16:58:27: Received Task 7                                                          
2021.08.23 16:58:27: Received Task 9                                                          
2021.08.23 16:58:27: Complete task "Task 7"                                            
2021.08.23 16:58:27: Complete task "Task 3"                                            
2021.08.23 16:58:27: Complete task "Task 1"                                            
2021.08.23 16:58:28: Complete task "Task 5"                                            
2021.08.23 16:58:28: Complete task "Task 9"

```

Як бачимо, брокер рівномірно розподіляє завдання між працівниками. Кожен з них спочатку отримує повідомлення, потім виконує завдання. Такий розподіл не враховує час виконання завдань та може призводити до дисбалансу навантаження працівників.

Щоб вирівняти навантаження працівників треба отримувати наступне повідомлення після того, як виконане поточне. Для цього можна
використати налаштування каналу

```js {17}

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    
    await channel.assertQueue(config.queue.TASK)

    channel.prefetch(1);
    
    channel.consume(config.queue.TASK, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`Received ${task.name}`);
            setTimeout(() => {
                log(`Complete task "${task.name}"`);
                channel.ack(msg);
            }, task.duration)
        }, 
        { noAck: false }
    )

}

run()

```

Після перезапуску двох працівників та генератора отримаємо бажаний результат.

Працівник 1:

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-worker                                                                   
2021.08.23 17:08:50: Received Task 0                                 
2021.08.23 17:08:51: Complete task "Task 0"                                            
2021.08.23 17:08:51: Received Task 2                                                   
2021.08.23 17:08:52: Complete task "Task 2"                                            
2021.08.23 17:08:52: Received Task 5                                                   
2021.08.23 17:08:52: Complete task "Task 5"                                            
2021.08.23 17:08:52: Received Task 6                                                   
2021.08.23 17:08:53: Complete task "Task 6"

```

Працівник 2:

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/task-worker
2021.08.23 17:08:50: Received Task 1                                 
2021.08.23 17:08:51: Complete task "Task 1"                                            
2021.08.23 17:08:52: Received Task 3                                                   
2021.08.23 17:08:52: Complete task "Task 3"                                            
2021.08.23 17:08:52: Received Task 4                                                   
2021.08.23 17:08:53: Complete task "Task 4"                                            
2021.08.23 17:08:53: Received Task 7                                                   
2021.08.23 17:08:53: Complete task "Task 7"                                            
2021.08.23 17:08:53: Received Task 8                                                   
2021.08.23 17:08:53: Complete task "Task 8"                                            
2021.08.23 17:08:53: Received Task 9                                                   
2021.08.23 17:08:54: Complete task "Task 9"


```

Як бачимо, навіть кількість завдань, виконаних працівниками, є різною. Кожне завдання має випадковий час виконання, а вибірка наступного повідомлення відбувається тільки після виконання поточного завдання.

Однією з переваг використання черги завдань є можливість легко паралелізувати роботу. Якщо ми накопичуємо відставання у роботі, ми можемо просто додати більше працівників і легко масштабуватись.

## Реалізація шаблону взаємодії PUB/SUB

В попередніх випадках кожне повідомлення передавалося лише одному споживачу. Шаблон PUB/SUB передбачає передачу одно й того самого повідомлення декільком споживачам.

Основна ідея моделі обміну повідомленнями в RabbitMQ полягає в тому, що продюсер ніколи не надсилає жодних повідомлень безпосередньо в чергу. Насправді, досить часто продюсер навіть не знає, чи буде взагалі доставлено повідомлення до якоїсь черги.

Натомість продюсер може лише надсилати повідомлення на обмінник . Обмінник - це дуже проста річ. З одного боку він отримує повідомлення від продюсерів, а з іншого - переміщує їх у черги. Обмінник повинен точно знати, що робити з отриманим повідомленням. Чи слід додавати його до певної черги? Його слід додати до багатьох черг? Або його слід викинути. Правила для цього визначаються типом обміну.

Доступно кілька видів обміну: ***direct***, ***topic***, ***headers*** та ***fanout***.

### Режим fanout

В режимі ***fanout*** обмінник просто транслює всі отримані повідомлення у всі відомі йому черги.

Створимо файл ```./src/event-publisher.js```, який буде генерувати послідовність подій

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
        
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assertion = await channel.assertExchange(
        config.exchange.LOGS, 
        'fanout', 
        { durable: false }
    );

    
    if( assertion ){
      for(let i=0; i<10; i++) {
        let message = {
          name:`Task ${i}`,
          at: new Date(),
          duration: Math.round(Math.random()*1000)
        }
        let send = await channel.publish(config.exchange.LOGS, '', Buffer.from(JSON.stringify(message)));
        
        if(send) log(`Event Publisher publish "${JSON.stringify(message)}"`)  
      }
    }
    
    await channel.close()
    await connection.close()
    
}

run()

```

Від генератора завдань він відрізняється тим, що в ньому створюється обмінник

```js

...

let assertion = await channel.assertExchange(
        config.exchange.LOGS, 
        'fanout', 
        { durable: false }
    );

...

```

При виклику ```channel.assertExchange``` ми повинні вказати ім'я обмінника, тип обміну(в нашому випадку ```fanout``` ), налаштування персистентності повідомлень.

Наш генератор генерує 10 повідомлень та публікує їх в обміннику.

Створимо файл ```./src/event-logger1.js``` для першого споживача(підписника)

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()

    await channel.assertExchange(
        config.exchange.LOGS, 
        'fanout', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    await channel.bindQueue(assertion.queue, config.exchange.LOGS, '');

    channel.consume(assertion.queue, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(task.name);
        }, 
        { noAck: true }
    )

}

run()

```

Як і у випадку генератора, створюємо обмінник та отримуємо від каналу результат визначення черги. Об'єкт ```assertion``` містить ім'я черги для цього примірника логера:  ```assertion.queue```. 

Коли з'єднання, яке оголосило таку тимчасову чергу, закривається, вона буде видалена, оскільки оголошена як ```{ exclusive: true }```.

На наступному кроці слід прив'язати до черги ```binding```- правила, у відповідності з яким обмінник розподіляє повідомлення по чергам. Для режиму fanout маски на визначаються

```js

...

    await channel.assertExchange(
        config.exchange.LOGS, 
        'fanout', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    await channel.bindQueue(assertion.queue, config.exchange.LOGS, '');

...

```

Потім визначаємо обробник повідомлень, який виводить на консоль ```task.name```.

Другий логер (файл ```./src/event-logger2.js```)

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()

    await channel.assertExchange(
        config.exchange.LOGS, 
        'fanout', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    await channel.bindQueue(assertion.queue, config.exchange.LOGS, '');

    channel.consume(assertion.queue, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`${task.name} duration ${task.duration}ms`);
        }, 
        { noAck: true }
    )

}

run()

```


відрізняється від першого лише обробником подій. Він виводить на консоль ```task.duration```.

Запустимо 3 консолі: генератор та два логера. Отримаємо:

консоль генератора

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-publisher
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 0","at":"2021-08-23T15:21:03.088Z","duration":173}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 1","at":"2021-08-23T15:21:03.094Z","duration":927}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 2","at":"2021-08-23T15:21:03.095Z","duration":898}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 3","at":"2021-08-23T15:21:03.096Z","duration":120}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 4","at":"2021-08-23T15:21:03.096Z","duration":342}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 5","at":"2021-08-23T15:21:03.097Z","duration":332}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 6","at":"2021-08-23T15:21:03.097Z","duration":712}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 7","at":"2021-08-23T15:21:03.098Z","duration":107}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 8","at":"2021-08-23T15:21:03.098Z","duration":386}"
2021.08.23 18:21:03: Event Publisher publish "{"name":"Task 9","at":"2021-08-23T15:21:03.099Z","duration":455}"

```

консоль першого логера

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger1    
2021.08.23 18:21:03: Task 0                                        
2021.08.23 18:21:03: Task 1                                                                            
2021.08.23 18:21:03: Task 2                                                                            
2021.08.23 18:21:03: Task 3                                                                            
2021.08.23 18:21:03: Task 4                                                                            
2021.08.23 18:21:03: Task 5                                                                            
2021.08.23 18:21:03: Task 6                                                                            
2021.08.23 18:21:03: Task 7                                                                            
2021.08.23 18:21:03: Task 8                                                                            
2021.08.23 18:21:03: Task 9

```

консоль другого логера

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger2    
2021.08.23 18:21:03: Task 0 duration 173ms                         
2021.08.23 18:21:03: Task 1 duration 927ms                                              
2021.08.23 18:21:03: Task 2 duration 898ms                                              
2021.08.23 18:21:03: Task 3 duration 120ms                                              
2021.08.23 18:21:03: Task 4 duration 342ms                                              
2021.08.23 18:21:03: Task 5 duration 332ms                                              
2021.08.23 18:21:03: Task 6 duration 712ms                                              
2021.08.23 18:21:03: Task 7 duration 107ms                                              
2021.08.23 18:21:03: Task 8 duration 386ms                                              
2021.08.23 18:21:03: Task 9 duration 455ms 

```

Таким чином ми маємо можливість використовувати декілька обробників одного потоку подій.


### Режим direct

Режим ***direct*** дозволяє обміннику вибірково пересилати повідомлення до черг на основі використання ***ключа маршрутизації***. Повідомлення публікується в обміннику з певним ключем маршрутизації і потрапляє в усі черги, які пов'язані з цим обмінником аналогічним ключем маршрутизації. Ключ маршрутизації - це рядок. Пошук відповідності відбувається за допомогою перевірки рядків на еквівалентність.

Створимо файл ```./src/event-publisher-direct.js```, який імітує передачу повідомлень логування 

```js {29,40}

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

const messageType = [
  "info",
  "debug",
  "warning",
  "error",
  "debug",
  "warning",
  "info",
  "info",
  "info"
]

async function run () {
    
        
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assert = await channel.assertExchange(
        config.exchange.DIRECT, 
        'direct', 
        { durable: false }
  );

    
    if( assert ){
      for(let i=0; i<messageType.length; i++) {
        let message = {
          type:messageType[i],
          index: i
        }
        let send = await channel.publish(config.exchange.DIRECT, messageType[i], Buffer.from(JSON.stringify(message)));
        
        if(send) log(`Multiple Types Event Publisher publish "${JSON.stringify(message)}"`) 
      }
    }
    
    await channel.close()
    await connection.close()
    
}

run()


```

Від попереднього генератора подій він відрізняється типом обміну, який вказаний при створенні обмінника, та способом
публікації повідомлення: ключ маршрутизації вказано, як другий аргумент виклику ```channel.publish```.

Генератор надсилає в обмінник повідомлення, відповідні до елементів масиву ```messageType```.


Створимо файл ```./src/event-logger-direct.js```

```js {23-25}

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()

    await channel.assertExchange(
        config.exchange.DIRECT, 
        'direct', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'info')
    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'warning')
    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'error')

    channel.consume(assertion.queue, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`${task.index}: ${task.type}`);
        }, 
        { noAck: true }
    )

}

run()

```

Цей логер здійснює прив'язку своєї черги за допомогою ```binding``` на три ключі маршрутизації: ```info```,
```warning```, ```error```.


Другий логер (файл ```./src/event-debug-direct.js```)

```js {23-25}

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()

    await channel.assertExchange(
        config.exchange.DIRECT, 
        'direct', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'debug')
    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'warning')
    await channel.bindQueue(assertion.queue, config.exchange.DIRECT, 'error')

    channel.consume(assertion.queue, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`${task.index}: ${task.type}`);
        }, 
        { noAck: true }
    )

}

run()

```

налаштований на інший набір типів повідомлень: ```debug```, ```warning```, ```error```.

Обмінник буде надсилати повідомлення типу ```warning``` та ```error``` до обох черг.

Після запуску генератора та логерів в окремих консолях отримаємо результат:

консоль генератора

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-publisher-direct
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"info","index":0}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"debug","index":1}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"warning","index":2}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"error","index":3}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"debug","index":4}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"warning","index":5}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"info","index":6}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"info","index":7}"
2021.08.23 19:30:00: Multiple Types Event Publisher publish "{"type":"info","index":8}"

```

консоль першого логера

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger-direct
2021.08.23 19:30:00: 0: info                                 
2021.08.23 19:30:00: 2: warning                                                                    
2021.08.23 19:30:00: 3: error                                                                      
2021.08.23 19:30:00: 5: warning                                                                    
2021.08.23 19:30:00: 6: info                                                                          
2021.08.23 19:30:00: 7: info                                                                          
2021.08.23 19:30:00: 8: info 

```

консоль другого логера

```bash
D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-debug-direct
2021.08.23 19:30:00: 1: debug                                 
2021.08.23 19:30:00: 2: warning                                                                    
2021.08.23 19:30:00: 3: error                                                                      
2021.08.23 19:30:00: 4: debug                                                                        
2021.08.23 19:30:00: 5: warning

```


### Режим topic

В режимі ***topic*** повідомлення, надіслані до обмінника, не можуть мати довільний ключ-маршрутизатор - це повинен бути список слів, розділених крапками. Слова можуть бути будь-якими, але зазвичай вони вказують на деякі функції, пов’язані з повідомленням. Ключ прив’язки також повинен бути в тій самій формі. Логіка обміну topic подібна до direct - повідомлення, надіслане з певним ключем маршрутизації, буде доставлено до всіх черг, які пов'язані відповідним ключем прив'язки. Однак є два важливі особливі випадки використання масок для прив’язки ключів:
- ```*``` (зірочка) може замінити рівно одне слово.
- ```#``` (хеш) може замінити нуль або більше слів.

Якщо ми надішлемо повідомлення з ключем маршрутизації, яке не відповідає ні одній  масці, воно буде втрачене.

Створимо файл ```./src/event-publisher-topic.js``` для генератора подій

```js {10-20,29}

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

const messageType = [
  "class1.info.start",
  "class1.debug",
  "class2.warning",
  "class2.error",
  "class1.debug",
  "class3.warning",
  "class1.info.run",
  "class2.info.start",
  "class2.info.start"
]

async function run () {
    
        
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assert = await channel.assertExchange(
        config.exchange.TOPIC, 
        'topic', 
        { durable: false }
  );

    
    if( assert ){
      for(let i=0; i<messageType.length; i++) {
        let message = {
          type:messageType[i],
          index: i
        }
        let send = await channel.publish(config.exchange.TOPIC, messageType[i], Buffer.from(JSON.stringify(message)));
        
        if(send) log(`Multiple Types Event Publisher publish "${JSON.stringify(message)}"`) 
      }
    }
    
    await channel.close()
    await connection.close()
    
}

run()


```

Тепер типи наших повідомлень відповідають вимогам для ключів маршрутизації режиму topic. При створенні обмінника вказуємо тип обміну ```topic```.

Створимо файл ```./src/event-logger-topic.js``` для логера, який вібірково (на основі використання маски) виводить на консоль
повідомлення

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

let args = process.argv.slice(2);

if (args.length == 0) {
    console.log("Usage: node ./src/event-logger-topic <class>.<severity>.<action>");
    process.exit(1);
}


async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()

    await channel.assertExchange(
        config.exchange.TOPIC, 
        'topic', 
        { durable: false}
    )

    let assertion = await channel.assertQueue('', { exclusive: true })

    args.forEach(function(key) {
        channel.bindQueue(assertion.queue, config.exchange.TOPIC, key);
    });

    channel.consume(assertion.queue, 
        msg => {
            let task = JSON.parse(msg.content.toString())
            log(`${msg.fields.routingKey}: ${task.index}: ${task.type}`);
        }, 
        { noAck: true }
    )

}

run()

```

Саму маску, яка використовується в прив'язці черги, отримуємо з командного рядка. Ключ прив'язки складається з трьох
частин: ```<class>.<severity>.<action>```. 

Будемо запускати цей логер з різними масками. Також після запуску логера треба запустити генератор подій.

Для запуску ```node ./src/event-logger-topic "#"``` отримаємо

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger-topic "#"
2021.08.23 20:04:06: class1.info.start: 0: class1.info.start
2021.08.23 20:04:06: class1.debug: 1: class1.debug                    
2021.08.23 20:04:06: class2.warning: 2: class2.warning                      
2021.08.23 20:04:06: class2.error: 3: class2.error                          
2021.08.23 20:04:06: class1.debug: 4: class1.debug                              
2021.08.23 20:04:06: class3.warning: 5: class3.warning                      
2021.08.23 20:04:06: class1.info.run: 6: class1.info.run                  
2021.08.23 20:04:06: class2.info.start: 7: class2.info.start          
2021.08.23 20:04:06: class2.info.start: 8: class2.info.start


```

Як бачимо, під маску ```#``` підпадають будь-які повідомлення.


Для запуску ```node ./src/event-logger-topic "*.*.start"``` отримаємо

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger-topic "*.*.start"
2021.08.23 20:07:37: class1.info.start: 0: class1.info.start
2021.08.23 20:07:37: class2.info.start: 7: class2.info.start          
2021.08.23 20:07:37: class2.info.start: 8: class2.info.start   

```

Як бачимо, під маску ```*.*.start``` підпадають повідомлення, ключ маршрутизації яких закінчується на ```start``` та має три слова.

Для запуску ```node ./src/event-logger-topic "class2.#"``` отримаємо

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/event-logger-topic "class2.#"
2021.08.23 20:10:38: class2.warning: 2: class2.warning
2021.08.23 20:10:38: class2.error: 3: class2.error                          
2021.08.23 20:10:38: class2.info.start: 7: class2.info.start          
2021.08.23 20:10:38: class2.info.start: 8: class2.info.start

```

Як бачимо, під маску ```class2.#``` підпадають повідомлення, ключ маршрутизації яких починається з ```class2``` та має довільну кількість слів.


Таким чином, використання режиму topic дає можливість гнучкого налаштування вибіркового оброблення повідомлень.

## Реалізація шаблону RPC

Віддалений виклик процедур (Remote Procedure Call, RPC) - клас технологій, що дозволяють програмам викликати функції або процедури на віддалених вузлах. Зазвичай реалізація RPC-технології включає два компоненти: мережевий протокол для обміну в режимі клієнт-сервер і мова сериализации об'єктів. 

Ідея виклику віддалених процедур полягає в розширенні механізму передачі управління і даних усередині програми, що виконується на одному вузлі, на передачу управління і даних через мережу. Засоби віддаленого виклику процедур призначені для полегшення організації розподілених обчислень і створення розподілених клієнт-серверних інформаційних систем. Найбільша ефективність використання RPC досягається в тих додатках, в яких існує інтерактивний зв'язок між віддаленими компонентами з невеликим часом відповідей і відносно малою кількістю переданих даних. Такі додатки називаються RPC-орієнтованими.

В EDA віддалений виклик процедур реалізують наступним чином

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;"
>

@startuml

participant Client as "RPC Client"

box "Message Broker" 
participant ReqQ as "Request\n<<Channel>>"
participant ResQ as "Reply\n<<Channel>>"
end box

participant S as "RPC Server"

Client -> ReqQ: RPC request + replyTo
ReqQ -> S: RPC request + replyTo
S -> S
S -> ResQ: RPC reply
ResQ -> Client: RPC reply

@enduml



</center>

Клієнт використовує чергу для передачі повідмлення про віддалений виклик. Також у повідомленні він передає назву черги для відправлення результату з боку сервера. Сервер отримує повідомлення про виклик з черги викликів, здійснює оброблення та надсилає відповідь в чергу відповідей, налаштування якої були задані клієнтом у повідомленні про виклик.

Назву черги для зворотного виклику клієнт може передати за допомогою властивості ```message.properties.replyTo```.

Сервер може виконувати оброблення декількох викликів асинхронно, тому послідовність відповідей в черзі відповідей може не співпадати з послідовністю викликів. Тобто кожен виклик повинен мати унікальний ідентифікатор, який передається клієнтом. Сервер потім використовує цей ідентифікатор для маркування відповідної відповіді. Тоді клієнт, отримавши повідомлення-відповідь, може співвіднести її з відповідним запитом.

Таку ідентифікацію можна здійснити через властивість ```message.properties.correlationId```.

Створимо файл ```./src/call-generator.js``` для клієнта

```js

const config = require("./config")
const moment = require("moment")
const uuid = require("uuid").v4
const { findIndex } = require("lodash")

const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}


let calls = [0,1,2,3,4,5].map( i => ({
    index: i,
    timeout: Math.round(Math.random()*5000),
    id: uuid()
}))

async function run () {
    
        
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    let assertion = await channel.assertQueue('', { exclusive: true } )

    channel.consume( assertion.queue, msg => {
            let refCallIndex = findIndex(calls, call => call.id == msg.properties.correlationId)
            if(refCallIndex >= -1) {
                log(`\nrpc: ${JSON.stringify(calls[refCallIndex])}\nresponse: ${msg.content}\n`)
            }
        },
        { noAsk: true }
    )

    calls.forEach( call => {
        setTimeout( () => {
            log(`send rpc: ${JSON.stringify(call)}`)
            channel.sendToQueue(config.queue.RPC,
                Buffer.from(JSON.stringify(call)), {
                    correlationId: call.id,
                    replyTo: assertion.queue
                });
        }, 0) //call.timeout)
    })
    
}

run()



```    

Бібліотека [uuid](https://www.npmjs.com/package/uuid) буде нами використана для генерації унікальних ідентифікаторів.

Наш генератор створює послідовність віддалених викликів(6 викликів) через випадкові інтервали часу.

Спочатку створюємо тимчасову чергу відповідей та отримує її налаштування від брокера повідомлень. Визначаємо обробник повідомлень-відповідей, в якому співвідносимо відповідь і виклик на основі співпадіння ```call.id == msg.properties.correlationId```. Потів виводимо на консоль повідомлення про успішне завершення віддаленого виклику.

Для відправлення повідомлень-викликів використовуємо заздалегідь відому чергу викликів, яку "слухає" сервер. При надсиланні повідомлень задаємо значення  ```correlationId``` та ```replyTo```.


Створимо файл ```./src/call-server.js``` для сервера

```js

const config = require("./config")
const moment = require("moment")
const amqp = require("amqplib")

const log = message => {
    console.log(`${moment(new Date()).format("YYYY.MM.DD HH:mm:ss")}: ${message}`)
}

async function run () {
    
    let connection = await amqp.connect(config.AMQP_CONNECTION_URL)
    let channel = await connection.createChannel()
    
    await channel.assertQueue(config.queue.RPC,{durable: false})

    // channel.prefetch(1);
    
    channel.consume(config.queue.RPC, 
        msg => {
            let call = JSON.parse(msg.content.toString())
            let response = {
                index: call.index
            }

            setTimeout(() => {
                channel.sendToQueue(msg.properties.replyTo,
                Buffer.from(JSON.stringify(response)), {
                    correlationId: msg.properties.correlationId
                });

                channel.ack(msg);    
            }, call.timeout)
            
            
        }, 
        { noAck: false }
    )

}

run()

``` 

Сервер "слухає" відому всім клієнтам чергу викликів. В обробнику повідомлень здійснюється оброблення, надсилання
повідомлення-відповіді в чергу ```msg.properties.replyTo```, асоційовану з клієнтом. Це повідомлення має той самий 
```correlationId```, що і відповідний запит. Після вдалого оброблення запиту сервер підтверджує отримання повідомлення.

Запустимо сервер і клієнт у відповідних консолях та отримаємо результат.

консоль клієнта

```bash
D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/call-generator
2021.08.23 21:26:39: send rpc: {"index":0,"timeout":4931,"id":"b986ba8a-af8e-482f-8839-5da6a017b603"}
2021.08.23 21:26:39: send rpc: {"index":1,"timeout":3391,"id":"9100a684-a601-4429-994e-a7779e4d9dca"}
2021.08.23 21:26:39: send rpc: {"index":2,"timeout":4173,"id":"0bc9d498-24c9-4246-9bd3-c550d7dc2983"}
2021.08.23 21:26:39: send rpc: {"index":3,"timeout":1692,"id":"5583900c-b566-419e-bfd8-cce328efdce3"}
2021.08.23 21:26:39: send rpc: {"index":4,"timeout":4810,"id":"e0b628db-2bfe-4a17-bf68-80d3dc501189"}
2021.08.23 21:26:39: send rpc: {"index":5,"timeout":1584,"id":"3a19277e-3552-41dd-bdaa-68e84dd5c4e4"}
2021.08.23 21:26:41:         
rpc: {"index":5,"timeout":1584,"id":"3a19277e-3552-41dd-bdaa-68e84dd5c4e4"}
response: {"index":5}                                                                                                             
2021.08.23 21:26:41:                                                                                          
rpc: {"index":3,"timeout":1692,"id":"5583900c-b566-419e-bfd8-cce328efdce3"}
response: {"index":3}                                  
                                                                                                                                  
2021.08.23 21:26:43:                                                                                         
rpc: {"index":1,"timeout":3391,"id":"9100a684-a601-4429-994e-a7779e4d9dca"}
response: {"index":1}                                                                                        
                                                                                                                                  
2021.08.23 21:26:43:                                                                                         
rpc: {"index":2,"timeout":4173,"id":"0bc9d498-24c9-4246-9bd3-c550d7dc2983"}
response: {"index":2}                                  
                                                                                                                                  
2021.08.23 21:26:44:                                                                                          
rpc: {"index":4,"timeout":4810,"id":"e0b628db-2bfe-4a17-bf68-80d3dc501189"}
response: {"index":4}                                  
                                                                                                                                  
2021.08.23 21:26:44:                                                                                         
rpc: {"index":0,"timeout":4931,"id":"b986ba8a-af8e-482f-8839-5da6a017b603"}
response: {"index":0}   

```

Бачимо, що клієнт відправляє всі повідомлення, які на сервері виконуюються асинхронно, тому послідовність відповідей не співпадає з послідовністю викликів. Проте використання ```correlationId``` дозволяє вірно співвіднести запити та відповіді.

Якщо задати обмеження, що сервер отримує наступний виклик тільки після завершення поточного: ```channel.prefetch(1)```, послідовність викликів та відповідей буде співпадати.

```bash

D:\docs\EDU\2021\eda\javascript-nodejs>node ./src/call-generator  
2021.08.23 21:33:58: send rpc: {"index":0,"timeout":3661,"id":"7b40ff5b-9204-4b69-a9ad-138157f39074"}
2021.08.23 21:33:58: send rpc: {"index":1,"timeout":4167,"id":"b4621c12-324e-4e00-89df-c70095dd538b"}
2021.08.23 21:33:58: send rpc: {"index":2,"timeout":1730,"id":"afd6c080-ffdc-4207-a043-a616dbf77b3d"}
2021.08.23 21:33:58: send rpc: {"index":3,"timeout":2485,"id":"c7ade456-197e-4f2d-b6b4-7ce8382b526b"}
2021.08.23 21:33:58: send rpc: {"index":4,"timeout":3424,"id":"1246b715-48db-451d-bf04-b045d7303cfd"}
2021.08.23 21:33:58: send rpc: {"index":5,"timeout":1543,"id":"6d546e68-2ccd-4b9e-b047-164c7addd1b2"}
2021.08.23 21:34:02:         
rpc: {"index":0,"timeout":3661,"id":"7b40ff5b-9204-4b69-a9ad-138157f39074"}
response: {"index":0}                                                                                        
                                                                                                                                  
2021.08.23 21:34:07:                                                                                         
rpc: {"index":1,"timeout":4167,"id":"b4621c12-324e-4e00-89df-c70095dd538b"}
response: {"index":1}                                  
                                                                                                                                  
2021.08.23 21:34:09:                                                                                         
rpc: {"index":2,"timeout":1730,"id":"afd6c080-ffdc-4207-a043-a616dbf77b3d"}
response: {"index":2}                                  
                                                                                                                                  
2021.08.23 21:34:11:                                                                                         
rpc: {"index":3,"timeout":2485,"id":"c7ade456-197e-4f2d-b6b4-7ce8382b526b"}
response: {"index":3}                                  
                                                                                                                                  
2021.08.23 21:34:15:                                                                                         
rpc: {"index":4,"timeout":3424,"id":"1246b715-48db-451d-bf04-b045d7303cfd"}
response: {"index":4}                                  
                                                                                                                                  
2021.08.23 21:34:17:                                                                                         
rpc: {"index":5,"timeout":1543,"id":"6d546e68-2ccd-4b9e-b047-164c7addd1b2"}
response: {"index":5}                                                  

```