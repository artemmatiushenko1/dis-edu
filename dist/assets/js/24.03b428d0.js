(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{649:function(t,r,e){"use strict";e.r(r);var v=e(34),a=Object(v.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"архітектурні-принципи-проектування-розподілених-інформаціиних-систем"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#архітектурні-принципи-проектування-розподілених-інформаціиних-систем"}},[t._v("#")]),t._v(" Архітектурні принципи проектування розподілених інформаційних систем")]),t._v(" "),e("p",[t._v("Архітектура програмного забезпечення - сукупність найважливіших рішень про організацію програмної системи, яка включає вибір структурних елементів, їх інтерфейсів, за допомогою яких складена система, а також їх поведінки в рамках взаємодії структурних елементів;")]),t._v(" "),e("h2",{attrs:{id:"клієнт-серверна-архітектура"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#клієнт-серверна-архітектура"}},[t._v("#")]),t._v(" Клієнт-серверна архітектура")]),t._v(" "),e("p",[t._v("Клієнт-серверна архітектура передбачає розділення системи на дві групи компонентів: ті, що надають деяке обслуговування, - сервери, та ті які здійснюють запити до серверів в очікуванні обслуговування. Ці групи компонентів можуть розміщуватися в різних обчислювальних вузлах, з'єднаних обчислювальною мережею")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU9IW8Ay_9HK1ON4WeBYQBWO25nOU67hnOOBcq0aN28MJLiAXgvP5tPVd7PnoeMz5vlGT248e2u5NR2L814kXzIy5A2J0000",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Взаємодія клієнта і сервера здійснюєтося наступним чином")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU8g038oapCB4lDA59npCbFpIb24WbEBobABkBYu878AkdPG8GKhXQBKmjBKuX8kg01S2gRMHXTPRN51VbvnAXUNGsfU2j1c0000",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Одне з головних питань - це те, яким чином розділити клієнта і сервер. В застосунках, призначених для організації доступу користувачів до баз даних, рекомендують розглядати три рівня:")]),t._v(" "),e("ul",[e("li",[t._v("рівень подання (інтерфейсу користувача);")]),t._v(" "),e("li",[t._v("рівень бізнес-логіки (оброблення даних);")]),t._v(" "),e("li",[t._v("рівень даних.")])]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuUBYYWueIYrEpIj9BCdCprFmIQnCBOfLqDEpKuXsAYtEp4ijBbRmoK_FJ8PASM4NXkXmIIn9XAdZud98pKi1sW40",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Рівень подання зазвичай реалізується в клієнтах і містить програмний код, що забезпечує взаємодію користувача з застосунком. Складність цього програмного забезпечення може бути різною. Найпростіший варіант - Command Line Interface (CLI), в інших випадках - багаторівневий графічний інтерфейс користувача, реалізований у відповідності до моделі Model-View-ViewModel (MVVM).")]),t._v(" "),e("p",[t._v("Рівень бізнес-логіки містить сукупність правил, принципів і залежностей поведінки об'єктів предметної області, наприклад бухгалтегського обліку, управління підприємством, електронна комерція та ін.")]),t._v(" "),e("p",[t._v("На рівні даних розташовується програмне забезпечення, яке надає дані рівню бізнес-логіки та забезпечує їх персистентність, цілісність, конкурентний доступ. Таке програмне забезпечення зазвичай реалізує функціональність СУБД.")]),t._v(" "),e("p",[t._v("Найпростіший варіант клієнт-серверної архітектури передбачає, що клієнт не несе ніякого функціонального навантаження крім відображення інформації, що надається сервером.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuUBAoqz9LN3EoKpDAr6evb80WkY0ejHY83Un93C_Jy4diJArA9Qh5gfI8JYrg2or2ARKgRGuCo-rk5Z19pyzCncc62pbabYIYAGRcwaAUdQuZC0k3DQ0R30NbqDgNWhG8m00",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v('Дворівнева клієнт-серверна архітектура передбачає використання "товстих" клієнтів, які відповідальні за оброблення всіх даних та їх відображення. Сервер реалізовує лише функції збереження та надання даних. При цьому розподілення обчислювального навантаження між клієнтом і сервером складає 80/20. Проте саме сервер СУБД найчастіше стає в такій системі вузькім місцем.')]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuUBAoqz9LN3EoKpDAr6evb80WkY0ejHY83Un93C_Jy4diJArA1OYuLHQd9cNMboiu9EVdfaCawg56g8Gd5fKbbe4CyKbiIGHIGasKnNqx70PYbqOh07PO2ukXzIy5A170000",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Застосунки в рамках такої архітектури часто вимагають встановлення індивідуального з'єднання з базою даних для кожного з клієнтів. Постійна піддтримка великої кількості таких з'єднань потребує використання великої кількості ресурсів, нестача яких прозводить до перевантаження сервера та уповільнення оброблення клієнтських запитів.")]),t._v(" "),e("p",[t._v("Ще одним з суттєвих недоліків такого архітектурного рішення є те, що код застосунку виконується в кожному клієнті і кожне оновлення застосунку потребує перевстановлення на кожній робочій станції, що підвищує до нейприйнятного рівня вартість і складність адміністрування таких систем.")]),t._v(" "),e("p",[t._v("Багарошарові архітектури клієнт-сервер продовжують розвиток ідеї розділення застосунків на рівня подання, бізнес-логіки та даних до виділення слабко пов'язаних логічних компонентів та розташування їх в окремих серверах (сервери застосунків). Це забезпечило можливість перенести частину бізнес-логіки на серверні компоненти. За рахунок цього з'явилася можливість  використання пулів з'єднань з базою даних, частково спростилося адміністрування системи.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/RL312i8m3BtdAy8-m4-GENSH9WZ3a-mGro25sesc4qJyTqkxOG_DANalx-MHMZmvlpmDW9qKuz5ejXu_WA5k5ySIHl9wijZHczsGYEi9k-cXnm6-g_0mpqQFSRDdzsA795XbA2QuMgsRHRHbaUIpcGStHPxk98pODkT-Iz86D5ig9SFTFW_sRoDHlbU6eo2_252pLU5BFm00",alt:"uml diagram"}})]),t._v(" "),e("h2",{attrs:{id:"сервіс-оріентована-архітектура"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#сервіс-оріентована-архітектура"}},[t._v("#")]),t._v(" Сервіс-оріентована архітектура")]),t._v(" "),e("p",[t._v("Сервіс-орієнтована архітектура (Service-Oriented Architecture, SOA) – модульний підхід до розробки програмного забезпечення, що базується на використанні розподілених, слабо пов’язаних (англ. Low Coupling) замінних компонентів, оснащених стандартизованими інтерфейсами для взаємодії за стандартизованими протоколами. Програмні комплекси, розроблені відповідно до сервіс-орієнтованої архітектури, зазвичай реалізуються як набір веб-служб, взаємодіючих по стандартним мережевим протоколам.\nІнтерфейси компонентів в сервіс-орієнтованої архітектури інкапсулюють деталі реалізації (операційну систему, платформу, мову програмування) від інших компонентів, таким чином забезпечуючи комбінування і багаторазове використання компонентів для побудови складних розподілених програмних комплексів, забезпечуючи незалежність від використовуваних платформ та інструментів розробки, сприяючи масштабованості і керованості створюваних систем.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервісні компоненти")])]),t._v(" (чи сервіси) описуються програмними компонентами, що\nзабезпечують прозору мережеву адресацію. Сервіси - це відкриті, самовизначальні\nкомпоненти, що підтримують швидку побудову розподілених застосунків.\nПри цьому немає чіткого визначення, який об'єм послуг повинен надавати окремий\nсервіс, а ці послуги в мережах можуть розрізнятися наступним чином:")]),t._v(" "),e("ul",[e("li",[e("em",[e("strong",[t._v("Програмне забезпечення як послуга")])]),t._v(" (SaaS, англ. Software-as-a-Service) – модель, в\nякій споживачеві надається можливість використання прикладного програмного\nзабезпечення провайдера, що працює в хмарній інфраструктурі і доступного з різних\nклієнтських пристроїв або за допомогою тонкого клієнта, наприклад, з браузеру (веб-пошта)\nабо інтерфейс програми. Контроль і управління основною фізичною і віртуальною\nінфраструктурою хмари, у тому числі мережі, серверів, операційних систем, зберігання, або\nнавіть індивідуальних можливостей додатка (за винятком обмеженого набору призначених\nдля користувача налаштувань конфігурації додатка) здійснюється хмарним провайдером.")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Платформа як послуга")])]),t._v(" (PaaS, англ. Platform-as-a-Service) – модель, коли\nспоживачеві надається можливість використання хмарної інфраструктури для розміщення\nбазового програмного забезпечення для наступного розміщення на нім нових або існуючих\nзастосувань (власних, розроблених на замовлення або придбаних тиражованих застосувань).\nДо складу таких платформ входять інструментальні засоби створення, тестування і\nвиконання прикладного програмного забезпечення – системи управління базами даних,\nєднальне програмне забезпечення, середовища виконання мов програмування - надаються\nхмарним провайдером. Контроль і управління основною фізичною і віртуальною\nінфраструктурою хмари, у тому числі мережі, серверів, операційних систем, зберігання\nздійснюється хмарним провайдером, за винятком розроблених або встановлених\nзастосувань, а також, по можливості, параметрів конфігурації середовища (платформи).")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Інфраструктура як послуга")])]),t._v(" (IaaS, англ. IaaS or Infrastructure-as-a-Service) –\nнадається як можливість використання хмарної інфраструктури для самостійного управління\nресурсами обробки, зберігання, мереж і іншими фундаментальними обчислювальними\nресурсами, наприклад, споживач може встановлювати і запускати довільне програмне\nзабезпечення, яке може включати операційні системи, платформене і прикладне програмне\nзабезпечення. Споживач може контролювати операційні системи, віртуальні системи\nзберігання даних і встановлені застосування, а також обмежений контроль набору доступних\nсервісів (наприклад, міжмережевий екран, DNS). Контроль і управління основною фізичною і\nвіртуальною інфраструктурою хмари, у тому числі мережі, серверів, типів використовуваних\nопераційних систем, систем зберігання здійснюється хмарним провайдером.\nНеобхідно враховувати, що при реалізації дрібномодульного сервісу для отримання\nбажаного результату необхідно забезпечити координовану роботу декількох сервісів. В\nцьому випадку можна надавати елементарний об'єм функціонального навантаження і\nзабезпечувати високу міру повторного використання. А використання крупномодульних\nсервісів, дозволяє забезпечити хорошу інкапсуляцію функціональності, але ускладнює\nповторне використання цих вузькоспеціалізованих сервісів.")])]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Інтерфейс")])]),t._v(" забезпечує опис можливостей і якості послуг, що надаються, конкретним\nсервісом. У інтерфейсі визначається формат повідомлень, використовуваний для обміну\nінформацією, а також вхідні і вихідні параметри методів, підтримуваних сервісним\nкомпонентом. Від вибору мови і способу опису інтерфейсу залежать можливості програмної\nсумісності різних реалізацій сервіс-орієнтованої архітектури.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Транспорт")])]),t._v(" забезпечує обмін інформацією між окремими сервісними компонентами.\nРазом з відкритими стандартами опису інтерфейсів, використання гнучких транспортних\nпротоколів для обміну інформацією між сервісними компонентами дозволяє підвищити\nпрограмну сумісність сервіс-орієнтованої системи.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Реєстри")])]),t._v(" сервісів використовуються для пошуку сервісних компонентів, що\nзабезпечують необхідну функціональність. Серед усієї множини різних систем, що\nзабезпечують виявлення сервісів, можна виділити дві основні категорії: системи\nдинамічного виявлення і системи статичного виявлення. "),e("em",[t._v("Статичні")]),t._v(" системи виявлення сервісів (наприклад, UDDI) орієнтовані на зберігання інформації про сервіси в системах, що рідко змінюються. "),e("em",[t._v("Динамічні")]),t._v(" системи виявлення сервісів орієнтовані на системи, в яких допустима\nчаста поява і зникнення сервісних компонентів.")]),t._v(" "),e("p",[t._v("Найчастіше для реалізації сервіс-орієнтованої архітектури використовуються "),e("em",[e("strong",[t._v("веб-сервіси")])]),t._v(" – слабозв'язані програмні компоненти, що підтримують багатократне використання, які\nсемантично інкапсулюють окремі функціональні можливості і програмним чином доступні\nпо стандартних протоколах Інтернету. Веб-сервіси незалежні від платформи і мови\nпрограмування, оскільки базуються на обміні даними в форматах XML, JSON.")]),t._v(" "),e("p",[t._v("Більшість веб-сервісів використовують HTTP для передачі повідомлень. Це дає значну\nперевагу при розробці розподілених застосунків в масштабі Інтернет, оскільки зазвичай\nбрандмауери і проксі-сервери без обмежень пропускають HTTP-трафік, і в процесі взаємодії\nне виникає несподіваних труднощів.")]),t._v(" "),e("p",[t._v("SOA передбачає наявність трьох основних учасників : постачальника сервісу, споживача сервісу і реєстру сервісів . Постачальник сервісу реєструє свої сервіси в реєстрі, а споживач звертається до реєстру із запитом на виявлення сервісу, після чого взаємодіє з ним.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuU9ApialJL48JYqgoqnELQZcKW22Q1ZNEJ-t83ylDQyabgiMJMbGQdfcSKbHfK9YiO8IJ3rCK0dT8BXgR2OgEETa0aNGzVWN9MUa0ZKbbkGNWLLZSPQ2NgcU7Lvhh1JoorAB53n2GWAm6c2ZXyD6h1fHL91cEHUNGsfU2Z3C0G00",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Постачальник сервісу і його споживач виявляються незв'язаними - вони спілкуються за допомогою повідомлень. Оскільки інтерфейс повинен не залежати від платформи, то і технологія, використовувана для визначення повідомлень, також повинна не залежати від платформи.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/NP1X3e8m38N_znGD_yS1Y34atW1ECA5A4nnpAoRUthAnAFxhtdlVIxisYWsoFcO0hmCFxAqJlCnCJevQtw6DMFKKNZmGTdJdAE5T_QMo3L1ovhoH3OQKfm3wIbeQjcadwhg6OcQfmOcq-afMDkDapC6PPSfGtZQtDdXZDnOf8Qh5VHboerzOB_j1IcEWvqfH3kZNYtvnKSy2QBL4F-m3",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("SOA не прив'язана до жорсткої методології\nпроектування, впровадження або управління ІТ-інфраструктурою. Вона обмежується лише\nнизкою принципів:")]),t._v(" "),e("ul",[e("li",[e("em",[t._v("Розподілене проектування")]),t._v(". Рішення відносно внутрішніх особливостей\nінформаційних систем приймаються різними групами людей, що мають власні організаційні,\nполітичні і економічні мотиви.")]),t._v(" "),e("li",[e("em",[t._v("Постійність змін")]),t._v(". Окремі аспекти архітектури можуть зазнавати зміни у будь-який\nмомент часу.")]),t._v(" "),e("li",[e("em",[t._v("Послідовне вдосконалення")]),t._v(". Локальне поліпшення компонентів системи повинне\nпризводити до вдосконалення усієї системи в цілому – до зростання сумарної корисності\nкомпонентів того ж рівня, що і змінюваний, так само як і компонентів нижчого і більш високого")])]),t._v(" "),e("p",[t._v("Процес перетворення бізнес-логіки в логіку додатків і реалізація сервісів на основі цих\nвимог є процесом створення сервісно-орієнтованої інфраструктури для завдань\nпідприємства.")]),t._v(" "),e("p",[t._v("При час реалізації власної інфраструктури бажано дотримуватися деяких основних підходів,\nописаних нижче.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси повинні підтримувати повторне використання")])]),t._v(". SOA-системи повинні\nпідтримувати повторне використання усіх сервісів, незалежно від миттєвих вимог до їх\nфункціональних особливостей. Якщо при розробці системи постаратися максимально\nврахувати цю вимогу, то підвищуються шанси значно спростити процес рішення завдань, які\nнеодмінно з'являться в майбутньому, при розвитку системи. Також спочатку орієнтований на\nповторне використання сервіс дозволяє уникнути розробки \"обгортки\", яка б підлаштовувала\nстарий сервіс для вирішення нових завдань. Оскільки сервіс – набір взаємопов'язаних операцій, логіка\nкожної індивідуальної операції, що надається сервісом, повинна підтримувати повторне\nвикористання.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси повинні забезпечувати формальний контракт використання")])]),t._v(". Контракт\nсервісу надає наступну інформацію: кінцеву точку (service endpoint): адресу, по якій можна\nзвернутися до цього сервісу; усі операції, що надаються сервісом; усі повідомлення,\nпідтримувані кожною операцією; правила і характеристики сервісу і його операцій.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси мають бути слабопов’язані")])]),t._v(". Система сервісів є слабопов'язаною,\nякщо сервіс може отримувати інформацію про інший сервіс, залишаючись незалежним від\nвнутрішньої реалізації логіки цього сервісу. Це досягається за допомогою використання\nконтрактів сервісів. Слабопов’язаність програмних компонентів, що лежить в основі SOA,\nдозволяє значно спростити координацію розподілених систем і їх реконфігурацію.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси повинні абстрагувати внутрішню логіку")])]),t._v('. Кожен сервіс повинен діяти як\n"чорний ящик", що приховує свої деталі від навколишнього світу. Немає чіткого визначення,\nякий об\'єм логіки повинен поміщатися в окремому сервісі.')]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси мають бути сумісні")])]),t._v(". Сервіс може як самостійно реалізовувати логіку, так і\nзастосовувати інші сервіси для її реалізації. Сервіси мають бути спроектовані так, щоб\nпідтримувати можливість їх використання як елементи іншого сервісу. Принцип сумісності\nне залежить від того, чи використовує сервіс для виконання своєї роботи інші сервіси. Як\nприклад такої взаємодії сервісів виступає концепція оркестрації сервісів. В цьому випадку,\nсервіс-орієнтований процес (який в принципі може бути визначений як композиція сервісів)\nуправляється сервісом батьківського процесу, який включає інші сервіси, що є учасниками\nцього процесу.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси мають бути автономними")])]),t._v(". Властивість автономності вимагає, щоб область\nбізнес-логіки і ресурсів, використовуваних сервісом були обмежені явними межами. Це\nдозволяє сервісу самому управляти усіма своїми процесами. Також це усуває залежність від\nінших сервісів, що звільняє сервіс від зв'язків, які можуть перешкоджати його застосуванню і\nрозвитку. Питання автономності – найбільш важливий аргумент при розподілі бізнес-логіки\nна окремі сервіси.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси не повинні використовувати інформацію про стан.")])]),t._v(" Сервіси повинні зводити\nдо мінімуму об'єм інформації про стан, і час, протягом якого вони його контролюють.\nІнформація про\nстан – це певні дані, що характеризують поточну діяльність. Якщо сервіс несе\nвідповідальність за збереження стану протягом тривалішого часу, його здатність залишатися\nдоступним для інших клієнтів буде ускладнена. Незалежність від стану (statelessness)\nдозволяє підвищити можливості масштабованості і повторного використання сервісів.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сервіси повинні підтримувати виявлення.")])]),t._v("  Метадані сервісу\nповинні детально описати не лише загальну мету сервісу, але і функціональність, що\nреалізовується його операціями. На рівні СОА виявлення характеризує здатність\nархітектури забезпечити механізми пошуку, такі як реєстр або каталог. На рівні сервісу,\nпринцип виявлення відноситься до процесу проектування окремого сервісу, так щоб цей\nсервіс настільки піддавався виявленню, наскільки це можливо.")]),t._v(" "),e("h2",{attrs:{id:"архітектура-орієнтована-на-подіі"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#архітектура-орієнтована-на-подіі"}},[t._v("#")]),t._v(" Архітектура, орієнтована на  події")]),t._v(" "),e("p",[t._v("Архітектура, орієнтована на  події (Event-Driven Architectureб EDA) — шаблон архітектури програмного забезпечення, який призначений для створення подій, їх виявлення, споживання і реагування на них.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Подія")])]),t._v(" може бути визначена як важлива зміна стану системи або її компонентів, що потребує певної реакції. З формальної точки зору, те, що виробляється, публікується, поширюється, виявляється і споживається (як правило, асинхронно) є "),e("em",[e("strong",[t._v("повідомленням")])]),t._v(", яке називають сповіщенням про подію (або нотифікацією), а не самою подією, яка є зміною стану, що викликає появу повідомлення. Події не подорожують, вони просто відбуваються.")]),t._v(" "),e("p",[t._v("Цей архітектурний шаблон може застосовуватися при проектуванні і реалізації застосунків і систем, які передають події між слабкозв'язаними компонентами програмного забезпечення і сервісами (службами).")]),t._v(" "),e("p",[t._v("EDA складається з "),e("em",[e("strong",[t._v("емітерів")])]),t._v(" подій (або агентів) і споживачів подій (або стоків). "),e("em",[e("strong",[t._v("Стоки")])]),t._v(" несуть відповідальність за здійснення реагування на подію. Реакція не завжди може бути повністю забезпечена самим стоком. Наприклад, стік, може бути відповідальним лише за фільтрацію, трансформацію і відправку повідомлення до іншого компонента, або він може забезпечити повністю самостійну реакцію на таку подію. Перша категорія стоків може бути заснована на традиційних компонентах, таких як проміжне програмне забезпечення, орієнтоване на обробку повідомлень (Message Oriented Middleware, MOM), в той час, як друга категорія стоків (самостійна реакція в режимі онлайн) може вимагати більш придатної платформи (фреймворку) для виконання транзакцій.")]),t._v(" "),e("p",[t._v("EDA дозволяє розробляти застосунки і системи, які  можуть пристосовуються до непередбачуваних і асинхронних середовищ.")]),t._v(" "),e("p",[t._v("EDA може доповнювати сервісно-орієнтовану архітектуру SOA, оскільки сервіси (служби) можуть бути активовані тригерами, які ініціюються при настанні подій.")]),t._v(" "),e("p",[t._v("Зазвичай повідомлення складається з двох частин: заголовка та тіла. Заголовок може включати в себе інформацію таку як, наприклад, назва події, часова мітка події і тип події. Тіло — це частина, яка описує факт, що стався в дійсності. Тіло не слід плутати з шаблоном або логікою, яка може бути застосована як реакція на саме повідомлення.\nНаприклад, така структура повідомлення використовується в проекті "),e("a",{attrs:{href:"https://cloudevents.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Сloudevents"),e("OutboundLink")],1),t._v(", мета якого уніфікація способів визначення повідомлень та досягнення широких можливостей інтеграції ресурсів в глобальних розподлілених системах.")]),t._v(" "),e("div",{staticClass:"language-json extra-class"},[e("pre",{pre:!0,attrs:{class:"language-json"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"specversion"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.3"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"type"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"com.github.pull.create"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"source"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://github.com/cloudevents/spec/pull/123"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"id"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"70d3c768-63f8-40e7-aa9d-d197d530586b"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"time"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2019-07-04T17:31:00Z"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"datacontenttype"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"application/json"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"data"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"much"')]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"wow"')]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"myextension"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v('"some"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"thing"')]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("EDA складається з чотирьох логічних рівнів (шарів). Вона починається з виявлення факту, його технічного подання у формі повідомлення і закінчується непустою множиною реакцій на цю подію:")]),t._v(" "),e("ul",[e("li",[e("em",[e("strong",[t._v("Генератор подій")])]),t._v(". Першим логічним шаром є генератор подій, який виявляє факт і представляє цей факт подією. Оскільки фактом може бути практично все, що може бути сприйнято, то ним може бути і генератор подій. Наприклад, генератором може бути клієнт електронної пошти, система електронної комерції або певний тип датчика. Перетворення різних даних, отриманих від датчиків, в єдину стандартизовану форму повідомлень є основною проблемою при розробці та реалізації цього шару. Однак, враховуючи, що повідомлення є строго декларативним, можна легко застосовувати будь-які операції трансформації, тим самим усуваючи необхідність забезпечення високого рівня стандартизації.")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Канал подій")])]),t._v(". Канал подій — це механізм, через який повідомлення від генератора подій передається до обробника подій (стоку). Це може бути з'єднання TCP/IP або вхідний файл будь-якого типу (простий текст, формат XML, e-mail тощо). В один і той же час може бути відкрито кілька каналів подій. Оскільки обробник подій повинен працювати в режимі, наближеному до реального часу, канали подій зчитуються асинхронно. Події зберігаються в черзі каналу, очікуючи наступної обробки механізмом обробки подій.")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Механізм обробки подій")])]),t._v(". Механізм обробки подій є місцем, де подія ідентифікується і вибирається відповідна реакція на нього, яка потім виконується. Це також може призвести до породження низки дій.")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Післядія")])]),t._v(".  Наслідки події можуть проявитись багатьма різними способами і у різноманітних формах (наприклад, відправлення комусь повідомлення електронною поштою, вивід деякого попередження на екран, тощо.")])]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/NOyn2iCm34Ltdq9axmKob43f6Deh25i4GIqRoIxqzesJUd0tyVz_3xHOGIqrlfpB-y6UCqg1fwPGFUcOheyLq62wl-dSU39ZsQPnTajYDJQuQ-1oFU0Pid94_G0rXMlPMStmB-rbjpNsw2ZywDwCA_I5apYta8Jzhoy0",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Є три основні стилі оброблення повідомлень: простий, потоковий і складний. Часто всі ці три стилі комбінуються в EDA-системах.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Просте оброблення повідомлень")])]),t._v(" стосується визначених подій (notable events) - простих подій, для яких визначена післядія. Просте оброблення зазвичай використовується для управління потоком робіт в реальному часі, скорочуючи тим самим час затримки і вартість робіт.")]),t._v(" "),e("p",[t._v("При "),e("em",[e("strong",[t._v("обробленні потоку подій")])]),t._v(" прості події перевіряються на те, чи є вони визначеними, і, якщо післядія відома, передаються інформаційним підписникам. Обробка потоку подій зазвичай використовується для моніторингу та управління потоком інформації в реальному часі і на рівні підприємства, що дозволяє своєчасно приймати рішення.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Оброблення складних подій")])]),t._v(" дозволяє за шаблонами простих і визначених подій проводити аналіз того, чи сталася складна подія. Обробка складних подій полягає в оцінюванні взаємного впливу подій і в наступному виконанні дій. При цьому, типи подій можуть перетинатись, а події можуть виникати протягом тривалого періоду часу. Кореляція подій може бути причинною, тимчасовою або просторовою. Оброблення складних подій вимагає використання складних інтерпретаторів подій, визначення і підбору шаблонів подій, а також відповідних кореляційних методів. Оброблення складних подій зазвичай використовується для виявлення і реагування на аномальну поведінку, загрози і можливості у бізнесі.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Advanced Message Queuing Protocol, AMQP")])]),t._v(" —  відкритий протокол для передачі повідомлень між компонентами системи забезпечує можливості реалізації всіх стилей оброблення повідомлень. Основна ідея полягає в тому, що окремі підсистеми\nможуть обмінюватися даними через AMQP-брокер, який здійснює маршрутизацію, можливо забезпечує гарантоване доставлення\nповідомлень, розподілення потоків повідомлень, реалізовувати підписку на необхідні типи повідомлень.")]),t._v(" "),e("p",[t._v("В AMQP використовуються наступні поняття.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Повідомлення (message)")])]),t._v(" — одиниця даних, що передаються. Основна його частина ніяк не інтерпретується сервером, до повідомлення можна приєднувати структуровані заголовки.")]),t._v(" "),e("p",[t._v("***Точка обмена (exchange)***, в яку відправляються повідомлення. Точка обміну розподіляє повідомлення в одну або декілька черг. Вона не зберігає повідомлення. Точки обміну бувають трьох типів:")]),t._v(" "),e("ul",[e("li",[e("em",[e("strong",[t._v("fanout")])]),t._v(" — повідомлення передається у всі приєднані черги;")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("direct")])]),t._v(" — повідомлення передається в чергу з ім'ям, яке співпадає з ключем маршрутизації, який вказується під час відправлення повідомлення;")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("topic")])]),t._v(" — повідомлення передається в черги, для яких співпадає маска для ключа маршрутизації, наприклад, "),e("code",[t._v("app.notification.sms.#")]),t._v(" — в чергу будуть доставлені повідомлення, відправлені з ключами, що починаються з "),e("code",[t._v("app.notification.sms")]),t._v(".")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Черга (queue)")])]),t._v(" — сховище повідомлень, які зберігаються, поки не будуть забрані клієнтом. Клієнт забірає повідомлення з одної або декількох черг.")])]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Producer")])]),t._v(" - застосунок, який публікує повідомлення в exchange. Всі повідомлення відправляються в одну точку обміну, де перевіряються та перерозподіляються в черги.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Consumer")])]),t._v(" - застосунок, який отримує повідомлення з черги. Чегра повідомлень повинна бути готова до старта застосунку і повинна бути прив'язана до нього. Споживач може створювати.видаляти черги повідомлень, визначати спосіб заповннея черг за допомогою правил (bindings), вибирати різні точки обміну.")]),t._v(" "),e("p",[t._v("Коли застосунок створює чергу, може бути вказані:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("name")]),t._v(" - якщо не вказано, сервер сам обирає ім'я та відправляє його застосунку;")]),t._v(" "),e("li",[e("code",[t._v("exclusive")]),t._v(" - якщо цей параметр встановлено, черг існує поки існує поточне з'єднання. Після розриву з'єднання черга видаляється;")]),t._v(" "),e("li",[e("code",[t._v("durable")]),t._v(" - якщо встановлено, черга існує і активна після перезавантаження сервера. Однак черга може загубити повідомлення, що передавалися під час з'єднання.")])]),t._v(" "),e("p",[t._v("Більшість інтеграційних архітектур використовують базову функціональність:")]),t._v(" "),e("ul",[e("li",[t._v("базовий (default) exchange для відправників (producers) повідомлень;")]),t._v(" "),e("li",[t._v("базовый binding для черг, який сортує повідомлення на основі співпадіння ім'я черги та ключа маршрутизації.")])]),t._v(" "),e("p",[t._v("В результаті базовий binding дозволяє producer відправляти повідомлення начебто безпосередньо до черги, таким чином він емулює найпростішу схему відправлення повідомлень, яку розробники очікують від традиційного middleware. Базовый binding дозволяє використовувати AMQP без конкретного знання роботи механізмів binding и exchange.")]),t._v(" "),e("p",[t._v("Типові схеми взаємодії компонентів розподіленої системи з AMQP-брокером через AMQP-клієнт зображені нижче.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/TP5D3i8W48NtSuf9zxr0OqoDQvCsyG989qeiKFcvlnHA1QCxvkFDUpFGMyUCyt86MC91SB4mvN0mUlASJ0MPV2t8B3QdopWWdmKfrrIAirQAk1DQrVZ10l-AY2Qxsyte9va682TZUuo17V9a2Z4-q5MVYaFRfeeROexA-2mkKEdymHW2OdSUCdjjPQ5S-pPQUINMXMKi6JTwyWGRpFDs-5enXWTWqkwt-m8__IofwQh_-4cobjq90FeW2n_u1W00",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Застосунок "),e("code",[t._v("Producer")]),t._v(", використовуючи "),e("code",[t._v("AMQP client")]),t._v(", здійснює з'єднання з "),e("code",[t._v("AMQP broker")]),t._v(", створює "),e("code",[t._v("Channel")]),t._v(", через який взаємодіє з чергами повідомлень.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/RPBF3e8m3CRlUug6Eoz0ZC5uyMAYZr17eqGsS1i-lsL_O5DFMtzhl_QZjDQXSRCQnCHdB_i9jOF3-Ne1j53voysCJp9LaN5yeDPKLXr7HjBreoumgjUqYScX9-qgyLrfPqMcW2VKtS1CYFGCzTwhDI13A-6rcIxI8TZLTOYa8NIK3vMICvGhRnYuWQzEBfDM3BFCfMwZcrPW3VksPDnrffb4X6dU1buB1lQCogwltmRIPyZb_x6rfGmm4upj55cBzsAE91JF33Nmy1UWD-yh5riJq3v_FItGBteb7Gt4Fc9tu7sAbdJ7_zm7",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("З боку споживача майже так само створюється з'єднання, канал, підключення до черги. Слід зауважити, що в схемі взаємодії з підтвердженням отримання повідомлення вони видаляються на боці сервера лише після отримання підтвардження від споживача. Якщо підтвердження відсутнє, можлива повторна вибірка повідомлень після перезавантаження споживача.")]),t._v(" "),e("h2",{attrs:{id:"мікросервісна-архітектура"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#мікросервісна-архітектура"}},[t._v("#")]),t._v(" Мікросервісна архітектура")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Мікросервіси")])]),t._v(" — архітектурний стиль, за яким застосунок будується як сукупність невеличких сервісів, кожен з яких працює у своєму власному процесі та спілкується з рештою, використовуючи прості та швидкі протоколи передачі даних. Ці сервіси будуються навколо бізнес-потреб і розгортаються незалежно один від одного з використанням зазвичай повністю автоматизованого середовища. Існує абсолютний мінімум централізованого керування цими сервісами. Самі по собі вони можуть бути написані з використанням різних мов програмування і технологій зберігання даних.")]),t._v(" "),e("p",[t._v("Переваги, які надає цей підхід для розроблення надскладних інформаційних систем великою кількістю невеличких команд розробників, є настільки переконливими, що такі великі корпоративні гравці як Amazon, Netflix або eBay впровадили його для розробки  своїх систем.")]),t._v(" "),e("p",[t._v("Існують певні відмінності між мікросервісною архітектурою і SOA. В першу чергу, основна відмінність зводиться до сфери застосування. SOA орієнтована на корпоративну сферу, а архітектура мікросервісів  - на розробку застосунків.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Повторне використання")])]),t._v(". У SOA повторне використання інтеграцій є основною метою, а на рівні підприємства прагнення до певного рівня повторного використання має істотне значення. Повторне використання та спільний доступ до компонентів в архітектурі SOA підвищує масштабованість та ефективність. В архітектурі мікросервісів створення компонента мікросервіса, яке повторно використовується під час виконання у всьому додатку, призводить до виникнення залежностей. Вважається за краще повторно використовувати код, дублювати дані, щоб покращити роз’єднання.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Взаємодія сервісів")])]),t._v(". Служби багаторазового використання в SOA доступні по всьому підприємству з використанням переважно синхронних протоколів, таких як  RESTful AP. Однак  у  додатку для мікросервісів синхронні виклики вводять залежності в режимі реального часу, що призводить до втрати стійкості. Ці залежності також можуть викликати затримку, що впливає на продуктивність. У додатку для мікросервісів перевагу віддають моделям взаємодії, заснованим на асинхронному зв’язку.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Дублювання даних")])]),t._v(". Чітка мета надання послуг у SOA полягає в тому, щоб усі програми синхронно отримували та змінювали дані безпосередньо у своєму первинному джерелі, що зменшує потребу у підтримці складних шаблонів синхронізації даних. У додатках для мікросервісів в ідеалі кожна мікросервіс має локальний доступ до всіх даних, необхідних для забезпечення її незалежності від інших мікросервісів - і навіть від інших програм - навіть якщо це означає певне дублювання даних в інших системах.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Декомпозиція системи")])]),t._v(". Архітектури мікросервісів складаються з вузькоспеціалізованих служб, кожна з яких призначена для виконання одного завдання. Послуги, які складають SOA, можуть варіюватися від невеликих спеціалізованих послуг до послуг у масштабі всього підприємства.")]),t._v(" "),e("p",[t._v("Таким чином, для цих сервісів характерні три властивості:")]),t._v(" "),e("ul",[e("li",[t._v("кожен з них може мати власний стек, що включає базу і модель даних;")]),t._v(" "),e("li",[t._v("вони взаємодіють один з одним за допомогою поєднання REST API , потоків подій і брокера повідомлень;")]),t._v(" "),e("li",[t._v("модулі застосунку підбираються виходячи з конкретних потреб бізнесу.")])]),t._v(" "),e("p",[t._v("З точки зору бізнесу і організаційних завдань переваги мікросервісов зводяться до\nлегкості оновлення коду, різні команди можуть використовувати різні стеки для різних модулів,\nкомпоненти можуть масштабуватися незалежно один від одного.")]),t._v(" "),e("p",[t._v("Розділення системи на мікросервіси - це непросте завдання, алеіснує ряд перевірених стратегій, які можуть допомогти:")]),t._v(" "),e("ul",[e("li",[t._v("Декомпозиція за можливостями бізнесу та визначення послуг, що відповідають можливостям бізнесу.")]),t._v(" "),e("li",[t._v("Декомпозиція за допомогою дієслів або варіантів використання.")]),t._v(" "),e("li",[t._v("Декомпозиція за допомогою іменників або ресурсів. Сервіси відповідають за всі операції над сутностями/ресурсами певного типу.")])]),t._v(" "),e("p",[t._v("В ідеалі кожна служба повинна мати лише невеликий набір обов’язків. Є сенс застосувати принцип єдиної відповідальності до проектування послуг.")]),t._v(" "),e("p",[t._v("З точки зору того, яким чином клієнти отримують доступ до сервісів, існує декілька ключових питань.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Деталізованість API")])]),t._v(", що надаються мікросервісами, часто відрізняється від того, що потрібно клієнту. Мікросервіси зазвичай забезпечують дрібнозернисті API, що означає, що клієнтам потрібно взаємодіяти з декількома службами.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Різним клієнтам потрібні різні дані")])]),t._v(". Наприклад, версія веб-переглядача сторінки з інформацією про продукт настільного комп’ютера зазвичай є більш складною, ніж її мобільна версія.")]),t._v(" "),e("p",[t._v("Служби можуть використовувати "),e("em",[e("strong",[t._v("різноманітний набір протоколів")])]),t._v(", деякі з яких можуть бути не зручними для Інтернету.")]),t._v(" "),e("p",[t._v("Кількість екземплярів служби та їх розташування (хост+порт) змінюються динамічно. Розподіл на служби може змінюватися з плином часу і повинен бути прихований від клієнтів.")]),t._v(" "),e("p",[t._v("Ці проблеми вирішуються за допомогою шлюзу API, який є єдиною точкою входу для всіх клієнтів. Шлюз API обробляє запити одним із двох способів. Деякі запити просто передаються за допомогою проксі/маршрутизації до відповідної служби.  Для інших запитів - можливо перетворює протоколи та координує декілька сервісів.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/ZPD1QuD048Nl-oi6Vq30zLvY6maz64mjz51osEW4X8tAPaqhfV-zcrqrgzs8dcJcUxmtJrnV91EoEND2I5db2EaEs0My5CKL1UpKo8CV0fyVqJE4TNqWlnqO6p2kZWL72-m68pRIQ21og9LR2nali9I6ZxubYf9nUD73GMYKOVAwrMBr0bicyOkrTpFrc63tvS5C-nJ_5abpv4KsNlGnDxwssc3Dg_Py2-CFDczH-dvgE8TRCqM6u5iwEjNHnpfgwOAfBl0wMHZlarwY1SC7WDNgoN4riOitZAi3ukpRyAvgUcDhPc1N7qjH-X0TdqrS9ypOBwVf73qDuUXb9iHocixHan1hB7Frb_u1",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Для отримання результатів з декількох сервісів шлюз API реалізує API Composer")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuUBYAYnDBQfKqDLLY7OCy5Hmpiyjo2zEBOhbuaBbWrI0bHhYaZ329M4CiyKGR0rGhYmpELN1C1OYQeGYQWGLDKOHDGQwno4rBmNeP000",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("API Composer викликає служби, які володіють даними, і виконує з'єднання результатів.")]),t._v(" "),e("p",[t._v("Якщо запит клієнта пов'язаний з зміною стану бізнес-сутностей, що не мають єдиного представлення, оскільки кожен з сервісів має власну базу даних і працює з обмеженим контекстом бізнес-сутностей, необхідно реалізовувати механізми розподілених транзакцій.")]),t._v(" "),e("p",[t._v("Одним з способів реалізації розподілених транзакцій є сага, що складається з локальних транзакцій в кожному задіяному сервісі.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/ROz12eGm34NtEKNeVXQsEnU3T_04eGOfr2fDPivlO4QmwYhmt-D11b6g-baoR7PJJ1iLnR534dGZrs-AZ9rhgM-elz3GqE00m7gljrLxp6kaZ5gf24LDQpcOxt5X4PePhFzV7kmV2oSx7ClT7hXCzjiE",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Існує два способи координації саг:")]),t._v(" "),e("ul",[e("li",[e("em",[e("strong",[t._v("Хореографія")])]),t._v(" - кожна локальна транзакція публікує події, які ініціюють локальні транзакції в інших сервісах.")]),t._v(" "),e("li",[e("em",[e("strong",[t._v("Оркестрування")])]),t._v(" - використовується спеціальний оркестратор, що повідомляє учасникам, які локальні транзакції виконувати.")])]),t._v(" "),e("p",[t._v("Розглянемо приклади для завдання створення замовлення з перевіркою ліміту кридита для замовника.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сага на основі хореографії")])])]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/TL6zZi8m3Dxz55RtUu4ALOYeuwb3rbjogGKHRH8vfkBnpz2M8mDRzENxbOz57Cjjdi1vIOnc2XG5ieB1X-oYu63H5Mm67edH4Y_1KrCp_WaDm6-wO_DDfRWpuOdJLL6i-VsR8oqQM7uY7WxcucAagUjgUxFIpQr8cZygA8weqL1BRIrzrGTOb-9NfmF1CpaX7437Ff0Mi_g5UDw1liNqhBioHz0DYXiBngwF5ls5_FL168FW5EOW-wUgDvYfQ0NLctwBVYMwd3ajfDMEcgqd-GC0",alt:"uml diagram"}})]),t._v(" "),e("p",[e("code",[t._v("Order Service")]),t._v(" отримує запит та створює "),e("code",[t._v("Order")]),t._v(" в стані "),e("code",[t._v("PENDING")]),t._v(". Потім публікує повідомлення "),e("code",[t._v("Order Created")]),t._v(".\n"),e("code",[t._v("Customer Service")]),t._v(" перевіряє перевищення ліміту та публікує відповідне повідомлення. "),e("code",[t._v("OrderService")]),t._v(" підтверджує "),e("code",[t._v("Order")]),t._v(".")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Сага на основі оркестрування")])])]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/ZP91QyCm38Nl-XKYE-yFb3IKcHn73xdceZfAQvROHdRBVlwK9ca8RB2RUJmzVNhub399ley3aCr1q0oEVOQeehCkaizuRf0I5cVfMB1XUJZBnTuXzcbfw4gj3s9ldBAGvXNurlTCJ7l_5bW0NC8t5f-S4bqPFoHygOfxV_qSCFUKmwWGQOPelGtZIBvBhIzBSoFlUQYgttUQUbcwmQ5mr7F_ccRVeRB1FgRPexpw09Yhm_TA6mChJ9cdPa3xcpHzhI9CXKtQ0QDkSVxwKke3bdtG61k684VXhYelbP9EDpDgGkSoQ25gDWsOPdxyPmhT68TrGlSiwcBgmDGhvuP7CKfui5vtKb3z9Zy0",alt:"uml diagram"}})]),t._v(" "),e("p",[e("code",[t._v("Order Service")]),t._v(" отримує запит та створює "),e("code",[t._v("Saga orchestrator")]),t._v(". Він створює "),e("code",[t._v("Order")]),t._v(" в стані "),e("code",[t._v("PENDING")]),t._v(" та посилає команду резервування кредиту. "),e("code",[t._v("Customer Service")]),t._v(" резервує кредит та публікує відповідь. ``Saga orchestrator"),e("code",[t._v("підтверджує")]),t._v("Order```.")]),t._v(" "),e("p",[t._v("Клієнт, який ініціює сагу,що реалізується асинхронним потоком, використовуючи синхронний запит (наприклад, "),e("code",[t._v("HTTP POST /orders")]),t._v("), повинен мати можливість визначити її результат. Існує кілька варіантів:")]),t._v(" "),e("ul",[e("li",[t._v("Сервіс надсилає відповідь, як тільки сага завершується, наприклад, коли вона отримує подію "),e("code",[t._v("OrderApproved")]),t._v("\nабо "),e("code",[t._v("OrderRejected")]),t._v(".")]),t._v(" "),e("li",[t._v("Сервіс надсилає відповідь (наприклад, "),e("code",[t._v("orderID")]),t._v(") після ініціювання саги, а клієнт періодично опитує (\nнаприклад "),e("code",[t._v("GET /orders/{orderID}")]),t._v("), щоб визначити результат.")]),t._v(" "),e("li",[t._v("Сервіс надсилає відповідь (наприклад, "),e("code",[t._v("orderID")]),t._v(") після ініціації саги, а потім надсилає клієнту подію (наприклад, websocket, веб-хук тощо) після завершення саги.")])]),t._v(" "),e("p",[t._v("Склад сервісів в мікросервісній архітектурі постійно оновлюється і є доволі мінливим, особливо у випадку динамічноно масштабування, коли сервіси можуть перерозташовуватись на різних обчислювальних вузлах (типова ситуація для хмарної інфраструктури). Тому вирішення завдання виявлення ресурсів є надзвичайно важливим.")]),t._v(" "),e("p",[t._v("Можна використати різні схеми виявлення ресурсів.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Виявлення ресурсів на клієнтському боці")])]),t._v(" передбачає, що під час надсилання запиту до служби клієнт отримує місцезнаходження екземпляра служби, запитуючи реєстр сервісів, який знає розташування всіх екземплярів сервісу.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Виявлення ресурсів на серверному боці")])]),t._v(" передбачає, що під час надсилання запиту до служби клієнт робить запит через маршрутизатор, який працює у добре відомому місці. Маршрутизатор запитує реєстр сервісів, який може бути вбудований у маршрутизатор, і пересилає запит до доступного екземпляра служби.")]),t._v(" "),e("p",[e("em",[e("strong",[t._v("Реєстр сервісів")])]),t._v(" - це база даних сервісів та їх розташування. Екземпляри служби реєструються в реєстрі сервісів під час запуску та скасовують регістрацію після завершення роботи. Клієнт служби та/або маршрутизатори запитують реєстр сервісів, щоб знайти доступні екземпляри. Реєстр сервісів може викликати API перевірки справності екземпляра сервісу, щоб перевірити його здатність обробляти запити (heart-beating).")]),t._v(" "),e("p",[t._v("Зазвичай екземпляр сервісу відповідає за реєстрацію себе в реєстрі. При запуску екземпляр сервісу реєструється (хост та IP -адреса) у реєстрі і стає доступним для виявлення. Зазвичай сервіс повинен періодично поновлювати реєстрацію, щоб реєстр знав, що він все ще живий. Після завершення роботи екземпляр служби скасовує реєстрацію з реєстру служб.")]),t._v(" "),e("p",[t._v("Схема взаємодії для механізму виявлення ресурсів з використанням обміну повідомленнями наведена нижче.")]),t._v(" "),e("center",{staticStyle:{"border-radius":"4px",border:"1px solid #cfd7e6","box-shadow":"0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025)",padding:"1em"}},[e("img",{attrs:{src:"https://www.plantuml.com/plantuml/svg/XL8zRy8m4DtzAqwP2zqHGj2020DI5OOEfSEHN1CBOwUsanPL_Uyz9r0reL8dM_PxzpxikVDeVNrIek9LPh92xM6n1dGGBHuti4PFxtYEXEWXTccBs95jP4QGKY6TjxUmnQg7My1AU-a3xc0-8DgISrWGF5Xp91j1dvpqoGcXykLUKqFQkxsUJkCIjIOrcqM2T0uySg0VR-9bEoFUtCTBLiqiSQ3WIxHterdOJo2dIfdp7RHr255OKrTm5NQaNi5s4T5BeuK8mG8tOUumN3V40NhuB8tpNmnFEdWgkBXsCm7Cynlgh-js27Xv8bEp8yudnkFnq5hN2MoDbjvOgOj_h9Kj_ay_blgILyM-u5Awp3Hapu8_oONvenBEfgDH_n1uK6MazbT6w3kbjvhrXh6UIj9STyVil4Btt20Tr1eRb0eFYk3vOXCoLEg0sV7bLvIS58LN7hORr8IOyy8__Xi0",alt:"uml diagram"}})]),t._v(" "),e("p",[t._v("Коли в системі присутні декілька екземплярів сервісу, функції балансувальника навантаження можуть бути інкапсульовані в реєстрі сервісів або в шлюзі API.")])],1)}),[],!1,null,null,null);r.default=a.exports}}]);